// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/a20070322/shop-go/ent/basicbanner"
	"github.com/a20070322/shop-go/ent/basicbannerposition"
	"github.com/a20070322/shop-go/ent/basiclink"
	"github.com/a20070322/shop-go/ent/customer"
	"github.com/a20070322/shop-go/ent/customeraddress"
	"github.com/a20070322/shop-go/ent/goodsclassify"
	"github.com/a20070322/shop-go/ent/goodssku"
	"github.com/a20070322/shop-go/ent/goodsspecs"
	"github.com/a20070322/shop-go/ent/goodsspecsoption"
	"github.com/a20070322/shop-go/ent/goodsspu"
	"github.com/a20070322/shop-go/ent/goodsspuimgs"
	"github.com/a20070322/shop-go/ent/orderaddress"
	"github.com/a20070322/shop-go/ent/ordergoodssku"
	"github.com/a20070322/shop-go/ent/orderinfo"
	"github.com/a20070322/shop-go/ent/predicate"
	"github.com/a20070322/shop-go/ent/schema"
	"github.com/a20070322/shop-go/ent/wechatpay"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBasicBanner         = "BasicBanner"
	TypeBasicBannerPosition = "BasicBannerPosition"
	TypeBasicLink           = "BasicLink"
	TypeCustomer            = "Customer"
	TypeCustomerAddress     = "CustomerAddress"
	TypeGoodsClassify       = "GoodsClassify"
	TypeGoodsSku            = "GoodsSku"
	TypeGoodsSpecs          = "GoodsSpecs"
	TypeGoodsSpecsOption    = "GoodsSpecsOption"
	TypeGoodsSpu            = "GoodsSpu"
	TypeGoodsSpuImgs        = "GoodsSpuImgs"
	TypeOrderAddress        = "OrderAddress"
	TypeOrderGoodsSku       = "OrderGoodsSku"
	TypeOrderInfo           = "OrderInfo"
	TypeWeChatPay           = "WeChatPay"
)

// BasicBannerMutation represents an operation that mutates the BasicBanner nodes in the graph.
type BasicBannerMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	banner_name                  *string
	banner_img                   *string
	_order                       *int
	add_order                    *int
	status                       *bool
	clearedFields                map[string]struct{}
	basic_banner_position        *int
	clearedbasic_banner_position bool
	basic_link                   *int
	clearedbasic_link            bool
	done                         bool
	oldValue                     func(context.Context) (*BasicBanner, error)
	predicates                   []predicate.BasicBanner
}

var _ ent.Mutation = (*BasicBannerMutation)(nil)

// basicbannerOption allows management of the mutation configuration using functional options.
type basicbannerOption func(*BasicBannerMutation)

// newBasicBannerMutation creates new mutation for the BasicBanner entity.
func newBasicBannerMutation(c config, op Op, opts ...basicbannerOption) *BasicBannerMutation {
	m := &BasicBannerMutation{
		config:        c,
		op:            op,
		typ:           TypeBasicBanner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBasicBannerID sets the ID field of the mutation.
func withBasicBannerID(id int) basicbannerOption {
	return func(m *BasicBannerMutation) {
		var (
			err   error
			once  sync.Once
			value *BasicBanner
		)
		m.oldValue = func(ctx context.Context) (*BasicBanner, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BasicBanner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBasicBanner sets the old BasicBanner of the mutation.
func withBasicBanner(node *BasicBanner) basicbannerOption {
	return func(m *BasicBannerMutation) {
		m.oldValue = func(context.Context) (*BasicBanner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BasicBannerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BasicBannerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *BasicBannerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *BasicBannerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BasicBannerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BasicBanner entity.
// If the BasicBanner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicBannerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BasicBannerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BasicBannerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BasicBannerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BasicBanner entity.
// If the BasicBanner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicBannerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *BasicBannerMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[basicbanner.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *BasicBannerMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[basicbanner.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BasicBannerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, basicbanner.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BasicBannerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BasicBannerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BasicBanner entity.
// If the BasicBanner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicBannerMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BasicBannerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[basicbanner.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BasicBannerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[basicbanner.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BasicBannerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, basicbanner.FieldDeletedAt)
}

// SetBannerName sets the "banner_name" field.
func (m *BasicBannerMutation) SetBannerName(s string) {
	m.banner_name = &s
}

// BannerName returns the value of the "banner_name" field in the mutation.
func (m *BasicBannerMutation) BannerName() (r string, exists bool) {
	v := m.banner_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerName returns the old "banner_name" field's value of the BasicBanner entity.
// If the BasicBanner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicBannerMutation) OldBannerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBannerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBannerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerName: %w", err)
	}
	return oldValue.BannerName, nil
}

// ResetBannerName resets all changes to the "banner_name" field.
func (m *BasicBannerMutation) ResetBannerName() {
	m.banner_name = nil
}

// SetBannerImg sets the "banner_img" field.
func (m *BasicBannerMutation) SetBannerImg(s string) {
	m.banner_img = &s
}

// BannerImg returns the value of the "banner_img" field in the mutation.
func (m *BasicBannerMutation) BannerImg() (r string, exists bool) {
	v := m.banner_img
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerImg returns the old "banner_img" field's value of the BasicBanner entity.
// If the BasicBanner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicBannerMutation) OldBannerImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBannerImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBannerImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerImg: %w", err)
	}
	return oldValue.BannerImg, nil
}

// ResetBannerImg resets all changes to the "banner_img" field.
func (m *BasicBannerMutation) ResetBannerImg() {
	m.banner_img = nil
}

// SetOrder sets the "order" field.
func (m *BasicBannerMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *BasicBannerMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the BasicBanner entity.
// If the BasicBanner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicBannerMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *BasicBannerMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *BasicBannerMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrder clears the value of the "order" field.
func (m *BasicBannerMutation) ClearOrder() {
	m._order = nil
	m.add_order = nil
	m.clearedFields[basicbanner.FieldOrder] = struct{}{}
}

// OrderCleared returns if the "order" field was cleared in this mutation.
func (m *BasicBannerMutation) OrderCleared() bool {
	_, ok := m.clearedFields[basicbanner.FieldOrder]
	return ok
}

// ResetOrder resets all changes to the "order" field.
func (m *BasicBannerMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
	delete(m.clearedFields, basicbanner.FieldOrder)
}

// SetStatus sets the "status" field.
func (m *BasicBannerMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BasicBannerMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BasicBanner entity.
// If the BasicBanner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicBannerMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BasicBannerMutation) ResetStatus() {
	m.status = nil
}

// SetBasicBannerPositionID sets the "basic_banner_position" edge to the BasicBannerPosition entity by id.
func (m *BasicBannerMutation) SetBasicBannerPositionID(id int) {
	m.basic_banner_position = &id
}

// ClearBasicBannerPosition clears the "basic_banner_position" edge to the BasicBannerPosition entity.
func (m *BasicBannerMutation) ClearBasicBannerPosition() {
	m.clearedbasic_banner_position = true
}

// BasicBannerPositionCleared reports if the "basic_banner_position" edge to the BasicBannerPosition entity was cleared.
func (m *BasicBannerMutation) BasicBannerPositionCleared() bool {
	return m.clearedbasic_banner_position
}

// BasicBannerPositionID returns the "basic_banner_position" edge ID in the mutation.
func (m *BasicBannerMutation) BasicBannerPositionID() (id int, exists bool) {
	if m.basic_banner_position != nil {
		return *m.basic_banner_position, true
	}
	return
}

// BasicBannerPositionIDs returns the "basic_banner_position" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BasicBannerPositionID instead. It exists only for internal usage by the builders.
func (m *BasicBannerMutation) BasicBannerPositionIDs() (ids []int) {
	if id := m.basic_banner_position; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBasicBannerPosition resets all changes to the "basic_banner_position" edge.
func (m *BasicBannerMutation) ResetBasicBannerPosition() {
	m.basic_banner_position = nil
	m.clearedbasic_banner_position = false
}

// SetBasicLinkID sets the "basic_link" edge to the BasicLink entity by id.
func (m *BasicBannerMutation) SetBasicLinkID(id int) {
	m.basic_link = &id
}

// ClearBasicLink clears the "basic_link" edge to the BasicLink entity.
func (m *BasicBannerMutation) ClearBasicLink() {
	m.clearedbasic_link = true
}

// BasicLinkCleared reports if the "basic_link" edge to the BasicLink entity was cleared.
func (m *BasicBannerMutation) BasicLinkCleared() bool {
	return m.clearedbasic_link
}

// BasicLinkID returns the "basic_link" edge ID in the mutation.
func (m *BasicBannerMutation) BasicLinkID() (id int, exists bool) {
	if m.basic_link != nil {
		return *m.basic_link, true
	}
	return
}

// BasicLinkIDs returns the "basic_link" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BasicLinkID instead. It exists only for internal usage by the builders.
func (m *BasicBannerMutation) BasicLinkIDs() (ids []int) {
	if id := m.basic_link; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBasicLink resets all changes to the "basic_link" edge.
func (m *BasicBannerMutation) ResetBasicLink() {
	m.basic_link = nil
	m.clearedbasic_link = false
}

// Op returns the operation name.
func (m *BasicBannerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BasicBanner).
func (m *BasicBannerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BasicBannerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, basicbanner.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, basicbanner.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, basicbanner.FieldDeletedAt)
	}
	if m.banner_name != nil {
		fields = append(fields, basicbanner.FieldBannerName)
	}
	if m.banner_img != nil {
		fields = append(fields, basicbanner.FieldBannerImg)
	}
	if m._order != nil {
		fields = append(fields, basicbanner.FieldOrder)
	}
	if m.status != nil {
		fields = append(fields, basicbanner.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BasicBannerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case basicbanner.FieldCreatedAt:
		return m.CreatedAt()
	case basicbanner.FieldUpdatedAt:
		return m.UpdatedAt()
	case basicbanner.FieldDeletedAt:
		return m.DeletedAt()
	case basicbanner.FieldBannerName:
		return m.BannerName()
	case basicbanner.FieldBannerImg:
		return m.BannerImg()
	case basicbanner.FieldOrder:
		return m.Order()
	case basicbanner.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BasicBannerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case basicbanner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case basicbanner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case basicbanner.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case basicbanner.FieldBannerName:
		return m.OldBannerName(ctx)
	case basicbanner.FieldBannerImg:
		return m.OldBannerImg(ctx)
	case basicbanner.FieldOrder:
		return m.OldOrder(ctx)
	case basicbanner.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown BasicBanner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BasicBannerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case basicbanner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case basicbanner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case basicbanner.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case basicbanner.FieldBannerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerName(v)
		return nil
	case basicbanner.FieldBannerImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerImg(v)
		return nil
	case basicbanner.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case basicbanner.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown BasicBanner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BasicBannerMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, basicbanner.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BasicBannerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case basicbanner.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BasicBannerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case basicbanner.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown BasicBanner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BasicBannerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(basicbanner.FieldUpdatedAt) {
		fields = append(fields, basicbanner.FieldUpdatedAt)
	}
	if m.FieldCleared(basicbanner.FieldDeletedAt) {
		fields = append(fields, basicbanner.FieldDeletedAt)
	}
	if m.FieldCleared(basicbanner.FieldOrder) {
		fields = append(fields, basicbanner.FieldOrder)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BasicBannerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BasicBannerMutation) ClearField(name string) error {
	switch name {
	case basicbanner.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case basicbanner.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case basicbanner.FieldOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown BasicBanner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BasicBannerMutation) ResetField(name string) error {
	switch name {
	case basicbanner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case basicbanner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case basicbanner.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case basicbanner.FieldBannerName:
		m.ResetBannerName()
		return nil
	case basicbanner.FieldBannerImg:
		m.ResetBannerImg()
		return nil
	case basicbanner.FieldOrder:
		m.ResetOrder()
		return nil
	case basicbanner.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown BasicBanner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BasicBannerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.basic_banner_position != nil {
		edges = append(edges, basicbanner.EdgeBasicBannerPosition)
	}
	if m.basic_link != nil {
		edges = append(edges, basicbanner.EdgeBasicLink)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BasicBannerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case basicbanner.EdgeBasicBannerPosition:
		if id := m.basic_banner_position; id != nil {
			return []ent.Value{*id}
		}
	case basicbanner.EdgeBasicLink:
		if id := m.basic_link; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BasicBannerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BasicBannerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BasicBannerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbasic_banner_position {
		edges = append(edges, basicbanner.EdgeBasicBannerPosition)
	}
	if m.clearedbasic_link {
		edges = append(edges, basicbanner.EdgeBasicLink)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BasicBannerMutation) EdgeCleared(name string) bool {
	switch name {
	case basicbanner.EdgeBasicBannerPosition:
		return m.clearedbasic_banner_position
	case basicbanner.EdgeBasicLink:
		return m.clearedbasic_link
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BasicBannerMutation) ClearEdge(name string) error {
	switch name {
	case basicbanner.EdgeBasicBannerPosition:
		m.ClearBasicBannerPosition()
		return nil
	case basicbanner.EdgeBasicLink:
		m.ClearBasicLink()
		return nil
	}
	return fmt.Errorf("unknown BasicBanner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BasicBannerMutation) ResetEdge(name string) error {
	switch name {
	case basicbanner.EdgeBasicBannerPosition:
		m.ResetBasicBannerPosition()
		return nil
	case basicbanner.EdgeBasicLink:
		m.ResetBasicLink()
		return nil
	}
	return fmt.Errorf("unknown BasicBanner edge %s", name)
}

// BasicBannerPositionMutation represents an operation that mutates the BasicBannerPosition nodes in the graph.
type BasicBannerPositionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	position_name       *string
	remarks             *string
	status              *bool
	clearedFields       map[string]struct{}
	basic_banner        map[int]struct{}
	removedbasic_banner map[int]struct{}
	clearedbasic_banner bool
	done                bool
	oldValue            func(context.Context) (*BasicBannerPosition, error)
	predicates          []predicate.BasicBannerPosition
}

var _ ent.Mutation = (*BasicBannerPositionMutation)(nil)

// basicbannerpositionOption allows management of the mutation configuration using functional options.
type basicbannerpositionOption func(*BasicBannerPositionMutation)

// newBasicBannerPositionMutation creates new mutation for the BasicBannerPosition entity.
func newBasicBannerPositionMutation(c config, op Op, opts ...basicbannerpositionOption) *BasicBannerPositionMutation {
	m := &BasicBannerPositionMutation{
		config:        c,
		op:            op,
		typ:           TypeBasicBannerPosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBasicBannerPositionID sets the ID field of the mutation.
func withBasicBannerPositionID(id int) basicbannerpositionOption {
	return func(m *BasicBannerPositionMutation) {
		var (
			err   error
			once  sync.Once
			value *BasicBannerPosition
		)
		m.oldValue = func(ctx context.Context) (*BasicBannerPosition, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BasicBannerPosition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBasicBannerPosition sets the old BasicBannerPosition of the mutation.
func withBasicBannerPosition(node *BasicBannerPosition) basicbannerpositionOption {
	return func(m *BasicBannerPositionMutation) {
		m.oldValue = func(context.Context) (*BasicBannerPosition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BasicBannerPositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BasicBannerPositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *BasicBannerPositionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *BasicBannerPositionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BasicBannerPositionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BasicBannerPosition entity.
// If the BasicBannerPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicBannerPositionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BasicBannerPositionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BasicBannerPositionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BasicBannerPositionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BasicBannerPosition entity.
// If the BasicBannerPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicBannerPositionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *BasicBannerPositionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[basicbannerposition.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *BasicBannerPositionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[basicbannerposition.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BasicBannerPositionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, basicbannerposition.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BasicBannerPositionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BasicBannerPositionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BasicBannerPosition entity.
// If the BasicBannerPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicBannerPositionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BasicBannerPositionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[basicbannerposition.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BasicBannerPositionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[basicbannerposition.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BasicBannerPositionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, basicbannerposition.FieldDeletedAt)
}

// SetPositionName sets the "position_name" field.
func (m *BasicBannerPositionMutation) SetPositionName(s string) {
	m.position_name = &s
}

// PositionName returns the value of the "position_name" field in the mutation.
func (m *BasicBannerPositionMutation) PositionName() (r string, exists bool) {
	v := m.position_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionName returns the old "position_name" field's value of the BasicBannerPosition entity.
// If the BasicBannerPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicBannerPositionMutation) OldPositionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPositionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPositionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionName: %w", err)
	}
	return oldValue.PositionName, nil
}

// ResetPositionName resets all changes to the "position_name" field.
func (m *BasicBannerPositionMutation) ResetPositionName() {
	m.position_name = nil
}

// SetRemarks sets the "remarks" field.
func (m *BasicBannerPositionMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the value of the "remarks" field in the mutation.
func (m *BasicBannerPositionMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old "remarks" field's value of the BasicBannerPosition entity.
// If the BasicBannerPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicBannerPositionMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ClearRemarks clears the value of the "remarks" field.
func (m *BasicBannerPositionMutation) ClearRemarks() {
	m.remarks = nil
	m.clearedFields[basicbannerposition.FieldRemarks] = struct{}{}
}

// RemarksCleared returns if the "remarks" field was cleared in this mutation.
func (m *BasicBannerPositionMutation) RemarksCleared() bool {
	_, ok := m.clearedFields[basicbannerposition.FieldRemarks]
	return ok
}

// ResetRemarks resets all changes to the "remarks" field.
func (m *BasicBannerPositionMutation) ResetRemarks() {
	m.remarks = nil
	delete(m.clearedFields, basicbannerposition.FieldRemarks)
}

// SetStatus sets the "status" field.
func (m *BasicBannerPositionMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BasicBannerPositionMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BasicBannerPosition entity.
// If the BasicBannerPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicBannerPositionMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BasicBannerPositionMutation) ResetStatus() {
	m.status = nil
}

// AddBasicBannerIDs adds the "basic_banner" edge to the BasicBanner entity by ids.
func (m *BasicBannerPositionMutation) AddBasicBannerIDs(ids ...int) {
	if m.basic_banner == nil {
		m.basic_banner = make(map[int]struct{})
	}
	for i := range ids {
		m.basic_banner[ids[i]] = struct{}{}
	}
}

// ClearBasicBanner clears the "basic_banner" edge to the BasicBanner entity.
func (m *BasicBannerPositionMutation) ClearBasicBanner() {
	m.clearedbasic_banner = true
}

// BasicBannerCleared reports if the "basic_banner" edge to the BasicBanner entity was cleared.
func (m *BasicBannerPositionMutation) BasicBannerCleared() bool {
	return m.clearedbasic_banner
}

// RemoveBasicBannerIDs removes the "basic_banner" edge to the BasicBanner entity by IDs.
func (m *BasicBannerPositionMutation) RemoveBasicBannerIDs(ids ...int) {
	if m.removedbasic_banner == nil {
		m.removedbasic_banner = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbasic_banner[ids[i]] = struct{}{}
	}
}

// RemovedBasicBanner returns the removed IDs of the "basic_banner" edge to the BasicBanner entity.
func (m *BasicBannerPositionMutation) RemovedBasicBannerIDs() (ids []int) {
	for id := range m.removedbasic_banner {
		ids = append(ids, id)
	}
	return
}

// BasicBannerIDs returns the "basic_banner" edge IDs in the mutation.
func (m *BasicBannerPositionMutation) BasicBannerIDs() (ids []int) {
	for id := range m.basic_banner {
		ids = append(ids, id)
	}
	return
}

// ResetBasicBanner resets all changes to the "basic_banner" edge.
func (m *BasicBannerPositionMutation) ResetBasicBanner() {
	m.basic_banner = nil
	m.clearedbasic_banner = false
	m.removedbasic_banner = nil
}

// Op returns the operation name.
func (m *BasicBannerPositionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BasicBannerPosition).
func (m *BasicBannerPositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BasicBannerPositionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, basicbannerposition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, basicbannerposition.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, basicbannerposition.FieldDeletedAt)
	}
	if m.position_name != nil {
		fields = append(fields, basicbannerposition.FieldPositionName)
	}
	if m.remarks != nil {
		fields = append(fields, basicbannerposition.FieldRemarks)
	}
	if m.status != nil {
		fields = append(fields, basicbannerposition.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BasicBannerPositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case basicbannerposition.FieldCreatedAt:
		return m.CreatedAt()
	case basicbannerposition.FieldUpdatedAt:
		return m.UpdatedAt()
	case basicbannerposition.FieldDeletedAt:
		return m.DeletedAt()
	case basicbannerposition.FieldPositionName:
		return m.PositionName()
	case basicbannerposition.FieldRemarks:
		return m.Remarks()
	case basicbannerposition.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BasicBannerPositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case basicbannerposition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case basicbannerposition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case basicbannerposition.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case basicbannerposition.FieldPositionName:
		return m.OldPositionName(ctx)
	case basicbannerposition.FieldRemarks:
		return m.OldRemarks(ctx)
	case basicbannerposition.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown BasicBannerPosition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BasicBannerPositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case basicbannerposition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case basicbannerposition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case basicbannerposition.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case basicbannerposition.FieldPositionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionName(v)
		return nil
	case basicbannerposition.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case basicbannerposition.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown BasicBannerPosition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BasicBannerPositionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BasicBannerPositionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BasicBannerPositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BasicBannerPosition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BasicBannerPositionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(basicbannerposition.FieldUpdatedAt) {
		fields = append(fields, basicbannerposition.FieldUpdatedAt)
	}
	if m.FieldCleared(basicbannerposition.FieldDeletedAt) {
		fields = append(fields, basicbannerposition.FieldDeletedAt)
	}
	if m.FieldCleared(basicbannerposition.FieldRemarks) {
		fields = append(fields, basicbannerposition.FieldRemarks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BasicBannerPositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BasicBannerPositionMutation) ClearField(name string) error {
	switch name {
	case basicbannerposition.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case basicbannerposition.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case basicbannerposition.FieldRemarks:
		m.ClearRemarks()
		return nil
	}
	return fmt.Errorf("unknown BasicBannerPosition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BasicBannerPositionMutation) ResetField(name string) error {
	switch name {
	case basicbannerposition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case basicbannerposition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case basicbannerposition.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case basicbannerposition.FieldPositionName:
		m.ResetPositionName()
		return nil
	case basicbannerposition.FieldRemarks:
		m.ResetRemarks()
		return nil
	case basicbannerposition.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown BasicBannerPosition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BasicBannerPositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.basic_banner != nil {
		edges = append(edges, basicbannerposition.EdgeBasicBanner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BasicBannerPositionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case basicbannerposition.EdgeBasicBanner:
		ids := make([]ent.Value, 0, len(m.basic_banner))
		for id := range m.basic_banner {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BasicBannerPositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbasic_banner != nil {
		edges = append(edges, basicbannerposition.EdgeBasicBanner)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BasicBannerPositionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case basicbannerposition.EdgeBasicBanner:
		ids := make([]ent.Value, 0, len(m.removedbasic_banner))
		for id := range m.removedbasic_banner {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BasicBannerPositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbasic_banner {
		edges = append(edges, basicbannerposition.EdgeBasicBanner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BasicBannerPositionMutation) EdgeCleared(name string) bool {
	switch name {
	case basicbannerposition.EdgeBasicBanner:
		return m.clearedbasic_banner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BasicBannerPositionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BasicBannerPosition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BasicBannerPositionMutation) ResetEdge(name string) error {
	switch name {
	case basicbannerposition.EdgeBasicBanner:
		m.ResetBasicBanner()
		return nil
	}
	return fmt.Errorf("unknown BasicBannerPosition edge %s", name)
}

// BasicLinkMutation represents an operation that mutates the BasicLink nodes in the graph.
type BasicLinkMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	link_name           *string
	link_type           *string
	link_address        *string
	appid               *string
	is_register         *bool
	remarks             *string
	status              *bool
	clearedFields       map[string]struct{}
	basic_banner        map[int]struct{}
	removedbasic_banner map[int]struct{}
	clearedbasic_banner bool
	done                bool
	oldValue            func(context.Context) (*BasicLink, error)
	predicates          []predicate.BasicLink
}

var _ ent.Mutation = (*BasicLinkMutation)(nil)

// basiclinkOption allows management of the mutation configuration using functional options.
type basiclinkOption func(*BasicLinkMutation)

// newBasicLinkMutation creates new mutation for the BasicLink entity.
func newBasicLinkMutation(c config, op Op, opts ...basiclinkOption) *BasicLinkMutation {
	m := &BasicLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeBasicLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBasicLinkID sets the ID field of the mutation.
func withBasicLinkID(id int) basiclinkOption {
	return func(m *BasicLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *BasicLink
		)
		m.oldValue = func(ctx context.Context) (*BasicLink, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BasicLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBasicLink sets the old BasicLink of the mutation.
func withBasicLink(node *BasicLink) basiclinkOption {
	return func(m *BasicLinkMutation) {
		m.oldValue = func(context.Context) (*BasicLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BasicLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BasicLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *BasicLinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *BasicLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BasicLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BasicLink entity.
// If the BasicLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BasicLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BasicLinkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BasicLinkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BasicLink entity.
// If the BasicLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicLinkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *BasicLinkMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[basiclink.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *BasicLinkMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[basiclink.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BasicLinkMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, basiclink.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BasicLinkMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BasicLinkMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BasicLink entity.
// If the BasicLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicLinkMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BasicLinkMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[basiclink.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BasicLinkMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[basiclink.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BasicLinkMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, basiclink.FieldDeletedAt)
}

// SetLinkName sets the "link_name" field.
func (m *BasicLinkMutation) SetLinkName(s string) {
	m.link_name = &s
}

// LinkName returns the value of the "link_name" field in the mutation.
func (m *BasicLinkMutation) LinkName() (r string, exists bool) {
	v := m.link_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkName returns the old "link_name" field's value of the BasicLink entity.
// If the BasicLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicLinkMutation) OldLinkName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLinkName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLinkName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkName: %w", err)
	}
	return oldValue.LinkName, nil
}

// ResetLinkName resets all changes to the "link_name" field.
func (m *BasicLinkMutation) ResetLinkName() {
	m.link_name = nil
}

// SetLinkType sets the "link_type" field.
func (m *BasicLinkMutation) SetLinkType(s string) {
	m.link_type = &s
}

// LinkType returns the value of the "link_type" field in the mutation.
func (m *BasicLinkMutation) LinkType() (r string, exists bool) {
	v := m.link_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkType returns the old "link_type" field's value of the BasicLink entity.
// If the BasicLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicLinkMutation) OldLinkType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLinkType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLinkType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkType: %w", err)
	}
	return oldValue.LinkType, nil
}

// ResetLinkType resets all changes to the "link_type" field.
func (m *BasicLinkMutation) ResetLinkType() {
	m.link_type = nil
}

// SetLinkAddress sets the "link_address" field.
func (m *BasicLinkMutation) SetLinkAddress(s string) {
	m.link_address = &s
}

// LinkAddress returns the value of the "link_address" field in the mutation.
func (m *BasicLinkMutation) LinkAddress() (r string, exists bool) {
	v := m.link_address
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkAddress returns the old "link_address" field's value of the BasicLink entity.
// If the BasicLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicLinkMutation) OldLinkAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLinkAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLinkAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkAddress: %w", err)
	}
	return oldValue.LinkAddress, nil
}

// ResetLinkAddress resets all changes to the "link_address" field.
func (m *BasicLinkMutation) ResetLinkAddress() {
	m.link_address = nil
}

// SetAppid sets the "appid" field.
func (m *BasicLinkMutation) SetAppid(s string) {
	m.appid = &s
}

// Appid returns the value of the "appid" field in the mutation.
func (m *BasicLinkMutation) Appid() (r string, exists bool) {
	v := m.appid
	if v == nil {
		return
	}
	return *v, true
}

// OldAppid returns the old "appid" field's value of the BasicLink entity.
// If the BasicLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicLinkMutation) OldAppid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAppid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAppid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppid: %w", err)
	}
	return oldValue.Appid, nil
}

// ClearAppid clears the value of the "appid" field.
func (m *BasicLinkMutation) ClearAppid() {
	m.appid = nil
	m.clearedFields[basiclink.FieldAppid] = struct{}{}
}

// AppidCleared returns if the "appid" field was cleared in this mutation.
func (m *BasicLinkMutation) AppidCleared() bool {
	_, ok := m.clearedFields[basiclink.FieldAppid]
	return ok
}

// ResetAppid resets all changes to the "appid" field.
func (m *BasicLinkMutation) ResetAppid() {
	m.appid = nil
	delete(m.clearedFields, basiclink.FieldAppid)
}

// SetIsRegister sets the "is_register" field.
func (m *BasicLinkMutation) SetIsRegister(b bool) {
	m.is_register = &b
}

// IsRegister returns the value of the "is_register" field in the mutation.
func (m *BasicLinkMutation) IsRegister() (r bool, exists bool) {
	v := m.is_register
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRegister returns the old "is_register" field's value of the BasicLink entity.
// If the BasicLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicLinkMutation) OldIsRegister(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsRegister is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsRegister requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRegister: %w", err)
	}
	return oldValue.IsRegister, nil
}

// ResetIsRegister resets all changes to the "is_register" field.
func (m *BasicLinkMutation) ResetIsRegister() {
	m.is_register = nil
}

// SetRemarks sets the "remarks" field.
func (m *BasicLinkMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the value of the "remarks" field in the mutation.
func (m *BasicLinkMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old "remarks" field's value of the BasicLink entity.
// If the BasicLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicLinkMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ClearRemarks clears the value of the "remarks" field.
func (m *BasicLinkMutation) ClearRemarks() {
	m.remarks = nil
	m.clearedFields[basiclink.FieldRemarks] = struct{}{}
}

// RemarksCleared returns if the "remarks" field was cleared in this mutation.
func (m *BasicLinkMutation) RemarksCleared() bool {
	_, ok := m.clearedFields[basiclink.FieldRemarks]
	return ok
}

// ResetRemarks resets all changes to the "remarks" field.
func (m *BasicLinkMutation) ResetRemarks() {
	m.remarks = nil
	delete(m.clearedFields, basiclink.FieldRemarks)
}

// SetStatus sets the "status" field.
func (m *BasicLinkMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BasicLinkMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BasicLink entity.
// If the BasicLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasicLinkMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BasicLinkMutation) ResetStatus() {
	m.status = nil
}

// AddBasicBannerIDs adds the "basic_banner" edge to the BasicBanner entity by ids.
func (m *BasicLinkMutation) AddBasicBannerIDs(ids ...int) {
	if m.basic_banner == nil {
		m.basic_banner = make(map[int]struct{})
	}
	for i := range ids {
		m.basic_banner[ids[i]] = struct{}{}
	}
}

// ClearBasicBanner clears the "basic_banner" edge to the BasicBanner entity.
func (m *BasicLinkMutation) ClearBasicBanner() {
	m.clearedbasic_banner = true
}

// BasicBannerCleared reports if the "basic_banner" edge to the BasicBanner entity was cleared.
func (m *BasicLinkMutation) BasicBannerCleared() bool {
	return m.clearedbasic_banner
}

// RemoveBasicBannerIDs removes the "basic_banner" edge to the BasicBanner entity by IDs.
func (m *BasicLinkMutation) RemoveBasicBannerIDs(ids ...int) {
	if m.removedbasic_banner == nil {
		m.removedbasic_banner = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbasic_banner[ids[i]] = struct{}{}
	}
}

// RemovedBasicBanner returns the removed IDs of the "basic_banner" edge to the BasicBanner entity.
func (m *BasicLinkMutation) RemovedBasicBannerIDs() (ids []int) {
	for id := range m.removedbasic_banner {
		ids = append(ids, id)
	}
	return
}

// BasicBannerIDs returns the "basic_banner" edge IDs in the mutation.
func (m *BasicLinkMutation) BasicBannerIDs() (ids []int) {
	for id := range m.basic_banner {
		ids = append(ids, id)
	}
	return
}

// ResetBasicBanner resets all changes to the "basic_banner" edge.
func (m *BasicLinkMutation) ResetBasicBanner() {
	m.basic_banner = nil
	m.clearedbasic_banner = false
	m.removedbasic_banner = nil
}

// Op returns the operation name.
func (m *BasicLinkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BasicLink).
func (m *BasicLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BasicLinkMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, basiclink.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, basiclink.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, basiclink.FieldDeletedAt)
	}
	if m.link_name != nil {
		fields = append(fields, basiclink.FieldLinkName)
	}
	if m.link_type != nil {
		fields = append(fields, basiclink.FieldLinkType)
	}
	if m.link_address != nil {
		fields = append(fields, basiclink.FieldLinkAddress)
	}
	if m.appid != nil {
		fields = append(fields, basiclink.FieldAppid)
	}
	if m.is_register != nil {
		fields = append(fields, basiclink.FieldIsRegister)
	}
	if m.remarks != nil {
		fields = append(fields, basiclink.FieldRemarks)
	}
	if m.status != nil {
		fields = append(fields, basiclink.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BasicLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case basiclink.FieldCreatedAt:
		return m.CreatedAt()
	case basiclink.FieldUpdatedAt:
		return m.UpdatedAt()
	case basiclink.FieldDeletedAt:
		return m.DeletedAt()
	case basiclink.FieldLinkName:
		return m.LinkName()
	case basiclink.FieldLinkType:
		return m.LinkType()
	case basiclink.FieldLinkAddress:
		return m.LinkAddress()
	case basiclink.FieldAppid:
		return m.Appid()
	case basiclink.FieldIsRegister:
		return m.IsRegister()
	case basiclink.FieldRemarks:
		return m.Remarks()
	case basiclink.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BasicLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case basiclink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case basiclink.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case basiclink.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case basiclink.FieldLinkName:
		return m.OldLinkName(ctx)
	case basiclink.FieldLinkType:
		return m.OldLinkType(ctx)
	case basiclink.FieldLinkAddress:
		return m.OldLinkAddress(ctx)
	case basiclink.FieldAppid:
		return m.OldAppid(ctx)
	case basiclink.FieldIsRegister:
		return m.OldIsRegister(ctx)
	case basiclink.FieldRemarks:
		return m.OldRemarks(ctx)
	case basiclink.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown BasicLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BasicLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case basiclink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case basiclink.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case basiclink.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case basiclink.FieldLinkName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkName(v)
		return nil
	case basiclink.FieldLinkType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkType(v)
		return nil
	case basiclink.FieldLinkAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkAddress(v)
		return nil
	case basiclink.FieldAppid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppid(v)
		return nil
	case basiclink.FieldIsRegister:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRegister(v)
		return nil
	case basiclink.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case basiclink.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown BasicLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BasicLinkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BasicLinkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BasicLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BasicLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BasicLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(basiclink.FieldUpdatedAt) {
		fields = append(fields, basiclink.FieldUpdatedAt)
	}
	if m.FieldCleared(basiclink.FieldDeletedAt) {
		fields = append(fields, basiclink.FieldDeletedAt)
	}
	if m.FieldCleared(basiclink.FieldAppid) {
		fields = append(fields, basiclink.FieldAppid)
	}
	if m.FieldCleared(basiclink.FieldRemarks) {
		fields = append(fields, basiclink.FieldRemarks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BasicLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BasicLinkMutation) ClearField(name string) error {
	switch name {
	case basiclink.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case basiclink.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case basiclink.FieldAppid:
		m.ClearAppid()
		return nil
	case basiclink.FieldRemarks:
		m.ClearRemarks()
		return nil
	}
	return fmt.Errorf("unknown BasicLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BasicLinkMutation) ResetField(name string) error {
	switch name {
	case basiclink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case basiclink.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case basiclink.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case basiclink.FieldLinkName:
		m.ResetLinkName()
		return nil
	case basiclink.FieldLinkType:
		m.ResetLinkType()
		return nil
	case basiclink.FieldLinkAddress:
		m.ResetLinkAddress()
		return nil
	case basiclink.FieldAppid:
		m.ResetAppid()
		return nil
	case basiclink.FieldIsRegister:
		m.ResetIsRegister()
		return nil
	case basiclink.FieldRemarks:
		m.ResetRemarks()
		return nil
	case basiclink.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown BasicLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BasicLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.basic_banner != nil {
		edges = append(edges, basiclink.EdgeBasicBanner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BasicLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case basiclink.EdgeBasicBanner:
		ids := make([]ent.Value, 0, len(m.basic_banner))
		for id := range m.basic_banner {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BasicLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbasic_banner != nil {
		edges = append(edges, basiclink.EdgeBasicBanner)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BasicLinkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case basiclink.EdgeBasicBanner:
		ids := make([]ent.Value, 0, len(m.removedbasic_banner))
		for id := range m.removedbasic_banner {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BasicLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbasic_banner {
		edges = append(edges, basiclink.EdgeBasicBanner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BasicLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case basiclink.EdgeBasicBanner:
		return m.clearedbasic_banner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BasicLinkMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BasicLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BasicLinkMutation) ResetEdge(name string) error {
	switch name {
	case basiclink.EdgeBasicBanner:
		m.ResetBasicBanner()
		return nil
	}
	return fmt.Errorf("unknown BasicLink edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	mini_openid       *string
	wechat_openid     *string
	union_id          *string
	phone             *string
	avatar            *string
	is_disable        *bool
	clearedFields     map[string]struct{}
	address           map[int]struct{}
	removedaddress    map[int]struct{}
	clearedaddress    bool
	order_info        map[int]struct{}
	removedorder_info map[int]struct{}
	clearedorder_info bool
	done              bool
	oldValue          func(context.Context) (*Customer, error)
	predicates        []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id int) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *CustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CustomerMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[customer.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CustomerMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[customer.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, customer.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CustomerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CustomerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CustomerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[customer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CustomerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[customer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CustomerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, customer.FieldDeletedAt)
}

// SetMiniOpenid sets the "mini_openid" field.
func (m *CustomerMutation) SetMiniOpenid(s string) {
	m.mini_openid = &s
}

// MiniOpenid returns the value of the "mini_openid" field in the mutation.
func (m *CustomerMutation) MiniOpenid() (r string, exists bool) {
	v := m.mini_openid
	if v == nil {
		return
	}
	return *v, true
}

// OldMiniOpenid returns the old "mini_openid" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldMiniOpenid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMiniOpenid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMiniOpenid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiniOpenid: %w", err)
	}
	return oldValue.MiniOpenid, nil
}

// ClearMiniOpenid clears the value of the "mini_openid" field.
func (m *CustomerMutation) ClearMiniOpenid() {
	m.mini_openid = nil
	m.clearedFields[customer.FieldMiniOpenid] = struct{}{}
}

// MiniOpenidCleared returns if the "mini_openid" field was cleared in this mutation.
func (m *CustomerMutation) MiniOpenidCleared() bool {
	_, ok := m.clearedFields[customer.FieldMiniOpenid]
	return ok
}

// ResetMiniOpenid resets all changes to the "mini_openid" field.
func (m *CustomerMutation) ResetMiniOpenid() {
	m.mini_openid = nil
	delete(m.clearedFields, customer.FieldMiniOpenid)
}

// SetWechatOpenid sets the "wechat_openid" field.
func (m *CustomerMutation) SetWechatOpenid(s string) {
	m.wechat_openid = &s
}

// WechatOpenid returns the value of the "wechat_openid" field in the mutation.
func (m *CustomerMutation) WechatOpenid() (r string, exists bool) {
	v := m.wechat_openid
	if v == nil {
		return
	}
	return *v, true
}

// OldWechatOpenid returns the old "wechat_openid" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldWechatOpenid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWechatOpenid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWechatOpenid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWechatOpenid: %w", err)
	}
	return oldValue.WechatOpenid, nil
}

// ClearWechatOpenid clears the value of the "wechat_openid" field.
func (m *CustomerMutation) ClearWechatOpenid() {
	m.wechat_openid = nil
	m.clearedFields[customer.FieldWechatOpenid] = struct{}{}
}

// WechatOpenidCleared returns if the "wechat_openid" field was cleared in this mutation.
func (m *CustomerMutation) WechatOpenidCleared() bool {
	_, ok := m.clearedFields[customer.FieldWechatOpenid]
	return ok
}

// ResetWechatOpenid resets all changes to the "wechat_openid" field.
func (m *CustomerMutation) ResetWechatOpenid() {
	m.wechat_openid = nil
	delete(m.clearedFields, customer.FieldWechatOpenid)
}

// SetUnionID sets the "union_id" field.
func (m *CustomerMutation) SetUnionID(s string) {
	m.union_id = &s
}

// UnionID returns the value of the "union_id" field in the mutation.
func (m *CustomerMutation) UnionID() (r string, exists bool) {
	v := m.union_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUnionID returns the old "union_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUnionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUnionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUnionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnionID: %w", err)
	}
	return oldValue.UnionID, nil
}

// ClearUnionID clears the value of the "union_id" field.
func (m *CustomerMutation) ClearUnionID() {
	m.union_id = nil
	m.clearedFields[customer.FieldUnionID] = struct{}{}
}

// UnionIDCleared returns if the "union_id" field was cleared in this mutation.
func (m *CustomerMutation) UnionIDCleared() bool {
	_, ok := m.clearedFields[customer.FieldUnionID]
	return ok
}

// ResetUnionID resets all changes to the "union_id" field.
func (m *CustomerMutation) ResetUnionID() {
	m.union_id = nil
	delete(m.clearedFields, customer.FieldUnionID)
}

// SetPhone sets the "phone" field.
func (m *CustomerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CustomerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *CustomerMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[customer.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *CustomerMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[customer.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *CustomerMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, customer.FieldPhone)
}

// SetAvatar sets the "avatar" field.
func (m *CustomerMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *CustomerMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *CustomerMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[customer.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *CustomerMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[customer.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *CustomerMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, customer.FieldAvatar)
}

// SetIsDisable sets the "is_disable" field.
func (m *CustomerMutation) SetIsDisable(b bool) {
	m.is_disable = &b
}

// IsDisable returns the value of the "is_disable" field in the mutation.
func (m *CustomerMutation) IsDisable() (r bool, exists bool) {
	v := m.is_disable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisable returns the old "is_disable" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldIsDisable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsDisable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsDisable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisable: %w", err)
	}
	return oldValue.IsDisable, nil
}

// ClearIsDisable clears the value of the "is_disable" field.
func (m *CustomerMutation) ClearIsDisable() {
	m.is_disable = nil
	m.clearedFields[customer.FieldIsDisable] = struct{}{}
}

// IsDisableCleared returns if the "is_disable" field was cleared in this mutation.
func (m *CustomerMutation) IsDisableCleared() bool {
	_, ok := m.clearedFields[customer.FieldIsDisable]
	return ok
}

// ResetIsDisable resets all changes to the "is_disable" field.
func (m *CustomerMutation) ResetIsDisable() {
	m.is_disable = nil
	delete(m.clearedFields, customer.FieldIsDisable)
}

// AddAddresIDs adds the "address" edge to the CustomerAddress entity by ids.
func (m *CustomerMutation) AddAddresIDs(ids ...int) {
	if m.address == nil {
		m.address = make(map[int]struct{})
	}
	for i := range ids {
		m.address[ids[i]] = struct{}{}
	}
}

// ClearAddress clears the "address" edge to the CustomerAddress entity.
func (m *CustomerMutation) ClearAddress() {
	m.clearedaddress = true
}

// AddressCleared reports if the "address" edge to the CustomerAddress entity was cleared.
func (m *CustomerMutation) AddressCleared() bool {
	return m.clearedaddress
}

// RemoveAddresIDs removes the "address" edge to the CustomerAddress entity by IDs.
func (m *CustomerMutation) RemoveAddresIDs(ids ...int) {
	if m.removedaddress == nil {
		m.removedaddress = make(map[int]struct{})
	}
	for i := range ids {
		m.removedaddress[ids[i]] = struct{}{}
	}
}

// RemovedAddress returns the removed IDs of the "address" edge to the CustomerAddress entity.
func (m *CustomerMutation) RemovedAddressIDs() (ids []int) {
	for id := range m.removedaddress {
		ids = append(ids, id)
	}
	return
}

// AddressIDs returns the "address" edge IDs in the mutation.
func (m *CustomerMutation) AddressIDs() (ids []int) {
	for id := range m.address {
		ids = append(ids, id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *CustomerMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
	m.removedaddress = nil
}

// AddOrderInfoIDs adds the "order_info" edge to the OrderInfo entity by ids.
func (m *CustomerMutation) AddOrderInfoIDs(ids ...int) {
	if m.order_info == nil {
		m.order_info = make(map[int]struct{})
	}
	for i := range ids {
		m.order_info[ids[i]] = struct{}{}
	}
}

// ClearOrderInfo clears the "order_info" edge to the OrderInfo entity.
func (m *CustomerMutation) ClearOrderInfo() {
	m.clearedorder_info = true
}

// OrderInfoCleared reports if the "order_info" edge to the OrderInfo entity was cleared.
func (m *CustomerMutation) OrderInfoCleared() bool {
	return m.clearedorder_info
}

// RemoveOrderInfoIDs removes the "order_info" edge to the OrderInfo entity by IDs.
func (m *CustomerMutation) RemoveOrderInfoIDs(ids ...int) {
	if m.removedorder_info == nil {
		m.removedorder_info = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_info[ids[i]] = struct{}{}
	}
}

// RemovedOrderInfo returns the removed IDs of the "order_info" edge to the OrderInfo entity.
func (m *CustomerMutation) RemovedOrderInfoIDs() (ids []int) {
	for id := range m.removedorder_info {
		ids = append(ids, id)
	}
	return
}

// OrderInfoIDs returns the "order_info" edge IDs in the mutation.
func (m *CustomerMutation) OrderInfoIDs() (ids []int) {
	for id := range m.order_info {
		ids = append(ids, id)
	}
	return
}

// ResetOrderInfo resets all changes to the "order_info" edge.
func (m *CustomerMutation) ResetOrderInfo() {
	m.order_info = nil
	m.clearedorder_info = false
	m.removedorder_info = nil
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, customer.FieldDeletedAt)
	}
	if m.mini_openid != nil {
		fields = append(fields, customer.FieldMiniOpenid)
	}
	if m.wechat_openid != nil {
		fields = append(fields, customer.FieldWechatOpenid)
	}
	if m.union_id != nil {
		fields = append(fields, customer.FieldUnionID)
	}
	if m.phone != nil {
		fields = append(fields, customer.FieldPhone)
	}
	if m.avatar != nil {
		fields = append(fields, customer.FieldAvatar)
	}
	if m.is_disable != nil {
		fields = append(fields, customer.FieldIsDisable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldDeletedAt:
		return m.DeletedAt()
	case customer.FieldMiniOpenid:
		return m.MiniOpenid()
	case customer.FieldWechatOpenid:
		return m.WechatOpenid()
	case customer.FieldUnionID:
		return m.UnionID()
	case customer.FieldPhone:
		return m.Phone()
	case customer.FieldAvatar:
		return m.Avatar()
	case customer.FieldIsDisable:
		return m.IsDisable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case customer.FieldMiniOpenid:
		return m.OldMiniOpenid(ctx)
	case customer.FieldWechatOpenid:
		return m.OldWechatOpenid(ctx)
	case customer.FieldUnionID:
		return m.OldUnionID(ctx)
	case customer.FieldPhone:
		return m.OldPhone(ctx)
	case customer.FieldAvatar:
		return m.OldAvatar(ctx)
	case customer.FieldIsDisable:
		return m.OldIsDisable(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case customer.FieldMiniOpenid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiniOpenid(v)
		return nil
	case customer.FieldWechatOpenid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWechatOpenid(v)
		return nil
	case customer.FieldUnionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnionID(v)
		return nil
	case customer.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case customer.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case customer.FieldIsDisable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisable(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldUpdatedAt) {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.FieldCleared(customer.FieldDeletedAt) {
		fields = append(fields, customer.FieldDeletedAt)
	}
	if m.FieldCleared(customer.FieldMiniOpenid) {
		fields = append(fields, customer.FieldMiniOpenid)
	}
	if m.FieldCleared(customer.FieldWechatOpenid) {
		fields = append(fields, customer.FieldWechatOpenid)
	}
	if m.FieldCleared(customer.FieldUnionID) {
		fields = append(fields, customer.FieldUnionID)
	}
	if m.FieldCleared(customer.FieldPhone) {
		fields = append(fields, customer.FieldPhone)
	}
	if m.FieldCleared(customer.FieldAvatar) {
		fields = append(fields, customer.FieldAvatar)
	}
	if m.FieldCleared(customer.FieldIsDisable) {
		fields = append(fields, customer.FieldIsDisable)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case customer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case customer.FieldMiniOpenid:
		m.ClearMiniOpenid()
		return nil
	case customer.FieldWechatOpenid:
		m.ClearWechatOpenid()
		return nil
	case customer.FieldUnionID:
		m.ClearUnionID()
		return nil
	case customer.FieldPhone:
		m.ClearPhone()
		return nil
	case customer.FieldAvatar:
		m.ClearAvatar()
		return nil
	case customer.FieldIsDisable:
		m.ClearIsDisable()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case customer.FieldMiniOpenid:
		m.ResetMiniOpenid()
		return nil
	case customer.FieldWechatOpenid:
		m.ResetWechatOpenid()
		return nil
	case customer.FieldUnionID:
		m.ResetUnionID()
		return nil
	case customer.FieldPhone:
		m.ResetPhone()
		return nil
	case customer.FieldAvatar:
		m.ResetAvatar()
		return nil
	case customer.FieldIsDisable:
		m.ResetIsDisable()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.address != nil {
		edges = append(edges, customer.EdgeAddress)
	}
	if m.order_info != nil {
		edges = append(edges, customer.EdgeOrderInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeAddress:
		ids := make([]ent.Value, 0, len(m.address))
		for id := range m.address {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeOrderInfo:
		ids := make([]ent.Value, 0, len(m.order_info))
		for id := range m.order_info {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedaddress != nil {
		edges = append(edges, customer.EdgeAddress)
	}
	if m.removedorder_info != nil {
		edges = append(edges, customer.EdgeOrderInfo)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeAddress:
		ids := make([]ent.Value, 0, len(m.removedaddress))
		for id := range m.removedaddress {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeOrderInfo:
		ids := make([]ent.Value, 0, len(m.removedorder_info))
		for id := range m.removedorder_info {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaddress {
		edges = append(edges, customer.EdgeAddress)
	}
	if m.clearedorder_info {
		edges = append(edges, customer.EdgeOrderInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeAddress:
		return m.clearedaddress
	case customer.EdgeOrderInfo:
		return m.clearedorder_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeAddress:
		m.ResetAddress()
		return nil
	case customer.EdgeOrderInfo:
		m.ResetOrderInfo()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// CustomerAddressMutation represents an operation that mutates the CustomerAddress nodes in the graph.
type CustomerAddressMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	name            *string
	phone           *string
	province        *string
	city            *string
	area            *string
	detailed        *string
	remark          *string
	is_default      *bool
	clearedFields   map[string]struct{}
	customer        *int
	clearedcustomer bool
	done            bool
	oldValue        func(context.Context) (*CustomerAddress, error)
	predicates      []predicate.CustomerAddress
}

var _ ent.Mutation = (*CustomerAddressMutation)(nil)

// customeraddressOption allows management of the mutation configuration using functional options.
type customeraddressOption func(*CustomerAddressMutation)

// newCustomerAddressMutation creates new mutation for the CustomerAddress entity.
func newCustomerAddressMutation(c config, op Op, opts ...customeraddressOption) *CustomerAddressMutation {
	m := &CustomerAddressMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomerAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerAddressID sets the ID field of the mutation.
func withCustomerAddressID(id int) customeraddressOption {
	return func(m *CustomerAddressMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomerAddress
		)
		m.oldValue = func(ctx context.Context) (*CustomerAddress, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomerAddress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomerAddress sets the old CustomerAddress of the mutation.
func withCustomerAddress(node *CustomerAddress) customeraddressOption {
	return func(m *CustomerAddressMutation) {
		m.oldValue = func(context.Context) (*CustomerAddress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerAddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerAddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *CustomerAddressMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerAddressMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerAddressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CustomerAddress entity.
// If the CustomerAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerAddressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerAddressMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerAddressMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerAddressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CustomerAddress entity.
// If the CustomerAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerAddressMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CustomerAddressMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[customeraddress.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CustomerAddressMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[customeraddress.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerAddressMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, customeraddress.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CustomerAddressMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CustomerAddressMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CustomerAddress entity.
// If the CustomerAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerAddressMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CustomerAddressMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[customeraddress.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CustomerAddressMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[customeraddress.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CustomerAddressMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, customeraddress.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *CustomerAddressMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CustomerAddressMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CustomerAddress entity.
// If the CustomerAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerAddressMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CustomerAddressMutation) ResetName() {
	m.name = nil
}

// SetPhone sets the "phone" field.
func (m *CustomerAddressMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CustomerAddressMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the CustomerAddress entity.
// If the CustomerAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerAddressMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *CustomerAddressMutation) ResetPhone() {
	m.phone = nil
}

// SetProvince sets the "province" field.
func (m *CustomerAddressMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *CustomerAddressMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the CustomerAddress entity.
// If the CustomerAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerAddressMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ResetProvince resets all changes to the "province" field.
func (m *CustomerAddressMutation) ResetProvince() {
	m.province = nil
}

// SetCity sets the "city" field.
func (m *CustomerAddressMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *CustomerAddressMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the CustomerAddress entity.
// If the CustomerAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerAddressMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *CustomerAddressMutation) ResetCity() {
	m.city = nil
}

// SetArea sets the "area" field.
func (m *CustomerAddressMutation) SetArea(s string) {
	m.area = &s
}

// Area returns the value of the "area" field in the mutation.
func (m *CustomerAddressMutation) Area() (r string, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldArea returns the old "area" field's value of the CustomerAddress entity.
// If the CustomerAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerAddressMutation) OldArea(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArea: %w", err)
	}
	return oldValue.Area, nil
}

// ResetArea resets all changes to the "area" field.
func (m *CustomerAddressMutation) ResetArea() {
	m.area = nil
}

// SetDetailed sets the "detailed" field.
func (m *CustomerAddressMutation) SetDetailed(s string) {
	m.detailed = &s
}

// Detailed returns the value of the "detailed" field in the mutation.
func (m *CustomerAddressMutation) Detailed() (r string, exists bool) {
	v := m.detailed
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailed returns the old "detailed" field's value of the CustomerAddress entity.
// If the CustomerAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerAddressMutation) OldDetailed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDetailed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDetailed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailed: %w", err)
	}
	return oldValue.Detailed, nil
}

// ResetDetailed resets all changes to the "detailed" field.
func (m *CustomerAddressMutation) ResetDetailed() {
	m.detailed = nil
}

// SetRemark sets the "remark" field.
func (m *CustomerAddressMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CustomerAddressMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the CustomerAddress entity.
// If the CustomerAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerAddressMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CustomerAddressMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[customeraddress.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CustomerAddressMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[customeraddress.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CustomerAddressMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, customeraddress.FieldRemark)
}

// SetIsDefault sets the "is_default" field.
func (m *CustomerAddressMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *CustomerAddressMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the CustomerAddress entity.
// If the CustomerAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerAddressMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *CustomerAddressMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetCustomerID sets the "customer" edge to the Customer entity by id.
func (m *CustomerAddressMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *CustomerAddressMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *CustomerAddressMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the "customer" edge ID in the mutation.
func (m *CustomerAddressMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *CustomerAddressMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *CustomerAddressMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// Op returns the operation name.
func (m *CustomerAddressMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CustomerAddress).
func (m *CustomerAddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerAddressMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, customeraddress.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customeraddress.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, customeraddress.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, customeraddress.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, customeraddress.FieldPhone)
	}
	if m.province != nil {
		fields = append(fields, customeraddress.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, customeraddress.FieldCity)
	}
	if m.area != nil {
		fields = append(fields, customeraddress.FieldArea)
	}
	if m.detailed != nil {
		fields = append(fields, customeraddress.FieldDetailed)
	}
	if m.remark != nil {
		fields = append(fields, customeraddress.FieldRemark)
	}
	if m.is_default != nil {
		fields = append(fields, customeraddress.FieldIsDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerAddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customeraddress.FieldCreatedAt:
		return m.CreatedAt()
	case customeraddress.FieldUpdatedAt:
		return m.UpdatedAt()
	case customeraddress.FieldDeletedAt:
		return m.DeletedAt()
	case customeraddress.FieldName:
		return m.Name()
	case customeraddress.FieldPhone:
		return m.Phone()
	case customeraddress.FieldProvince:
		return m.Province()
	case customeraddress.FieldCity:
		return m.City()
	case customeraddress.FieldArea:
		return m.Area()
	case customeraddress.FieldDetailed:
		return m.Detailed()
	case customeraddress.FieldRemark:
		return m.Remark()
	case customeraddress.FieldIsDefault:
		return m.IsDefault()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerAddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customeraddress.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customeraddress.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customeraddress.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case customeraddress.FieldName:
		return m.OldName(ctx)
	case customeraddress.FieldPhone:
		return m.OldPhone(ctx)
	case customeraddress.FieldProvince:
		return m.OldProvince(ctx)
	case customeraddress.FieldCity:
		return m.OldCity(ctx)
	case customeraddress.FieldArea:
		return m.OldArea(ctx)
	case customeraddress.FieldDetailed:
		return m.OldDetailed(ctx)
	case customeraddress.FieldRemark:
		return m.OldRemark(ctx)
	case customeraddress.FieldIsDefault:
		return m.OldIsDefault(ctx)
	}
	return nil, fmt.Errorf("unknown CustomerAddress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerAddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customeraddress.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customeraddress.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customeraddress.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case customeraddress.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customeraddress.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case customeraddress.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case customeraddress.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case customeraddress.FieldArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArea(v)
		return nil
	case customeraddress.FieldDetailed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailed(v)
		return nil
	case customeraddress.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case customeraddress.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerAddress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerAddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerAddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerAddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CustomerAddress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerAddressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customeraddress.FieldUpdatedAt) {
		fields = append(fields, customeraddress.FieldUpdatedAt)
	}
	if m.FieldCleared(customeraddress.FieldDeletedAt) {
		fields = append(fields, customeraddress.FieldDeletedAt)
	}
	if m.FieldCleared(customeraddress.FieldRemark) {
		fields = append(fields, customeraddress.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerAddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerAddressMutation) ClearField(name string) error {
	switch name {
	case customeraddress.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case customeraddress.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case customeraddress.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown CustomerAddress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerAddressMutation) ResetField(name string) error {
	switch name {
	case customeraddress.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customeraddress.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customeraddress.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case customeraddress.FieldName:
		m.ResetName()
		return nil
	case customeraddress.FieldPhone:
		m.ResetPhone()
		return nil
	case customeraddress.FieldProvince:
		m.ResetProvince()
		return nil
	case customeraddress.FieldCity:
		m.ResetCity()
		return nil
	case customeraddress.FieldArea:
		m.ResetArea()
		return nil
	case customeraddress.FieldDetailed:
		m.ResetDetailed()
		return nil
	case customeraddress.FieldRemark:
		m.ResetRemark()
		return nil
	case customeraddress.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	}
	return fmt.Errorf("unknown CustomerAddress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerAddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.customer != nil {
		edges = append(edges, customeraddress.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerAddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customeraddress.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerAddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerAddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerAddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcustomer {
		edges = append(edges, customeraddress.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerAddressMutation) EdgeCleared(name string) bool {
	switch name {
	case customeraddress.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerAddressMutation) ClearEdge(name string) error {
	switch name {
	case customeraddress.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown CustomerAddress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerAddressMutation) ResetEdge(name string) error {
	switch name {
	case customeraddress.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown CustomerAddress edge %s", name)
}

// GoodsClassifyMutation represents an operation that mutates the GoodsClassify nodes in the graph.
type GoodsClassifyMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	classify_name    *string
	classify_code    *string
	pid              *int
	addpid           *int
	level            *int
	addlevel         *int
	sort             *int
	addsort          *int
	icon             *string
	is_disable       *bool
	clearedFields    map[string]struct{}
	goods_spu        map[int]struct{}
	removedgoods_spu map[int]struct{}
	clearedgoods_spu bool
	done             bool
	oldValue         func(context.Context) (*GoodsClassify, error)
	predicates       []predicate.GoodsClassify
}

var _ ent.Mutation = (*GoodsClassifyMutation)(nil)

// goodsclassifyOption allows management of the mutation configuration using functional options.
type goodsclassifyOption func(*GoodsClassifyMutation)

// newGoodsClassifyMutation creates new mutation for the GoodsClassify entity.
func newGoodsClassifyMutation(c config, op Op, opts ...goodsclassifyOption) *GoodsClassifyMutation {
	m := &GoodsClassifyMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodsClassify,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodsClassifyID sets the ID field of the mutation.
func withGoodsClassifyID(id int) goodsclassifyOption {
	return func(m *GoodsClassifyMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodsClassify
		)
		m.oldValue = func(ctx context.Context) (*GoodsClassify, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodsClassify.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodsClassify sets the old GoodsClassify of the mutation.
func withGoodsClassify(node *GoodsClassify) goodsclassifyOption {
	return func(m *GoodsClassifyMutation) {
		m.oldValue = func(context.Context) (*GoodsClassify, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodsClassifyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodsClassifyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *GoodsClassifyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodsClassifyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodsClassifyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodsClassify entity.
// If the GoodsClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsClassifyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodsClassifyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodsClassifyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodsClassifyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodsClassify entity.
// If the GoodsClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsClassifyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *GoodsClassifyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[goodsclassify.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *GoodsClassifyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[goodsclassify.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodsClassifyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, goodsclassify.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodsClassifyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodsClassifyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodsClassify entity.
// If the GoodsClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsClassifyMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GoodsClassifyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[goodsclassify.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GoodsClassifyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[goodsclassify.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodsClassifyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, goodsclassify.FieldDeletedAt)
}

// SetClassifyName sets the "classify_name" field.
func (m *GoodsClassifyMutation) SetClassifyName(s string) {
	m.classify_name = &s
}

// ClassifyName returns the value of the "classify_name" field in the mutation.
func (m *GoodsClassifyMutation) ClassifyName() (r string, exists bool) {
	v := m.classify_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClassifyName returns the old "classify_name" field's value of the GoodsClassify entity.
// If the GoodsClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsClassifyMutation) OldClassifyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClassifyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClassifyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassifyName: %w", err)
	}
	return oldValue.ClassifyName, nil
}

// ClearClassifyName clears the value of the "classify_name" field.
func (m *GoodsClassifyMutation) ClearClassifyName() {
	m.classify_name = nil
	m.clearedFields[goodsclassify.FieldClassifyName] = struct{}{}
}

// ClassifyNameCleared returns if the "classify_name" field was cleared in this mutation.
func (m *GoodsClassifyMutation) ClassifyNameCleared() bool {
	_, ok := m.clearedFields[goodsclassify.FieldClassifyName]
	return ok
}

// ResetClassifyName resets all changes to the "classify_name" field.
func (m *GoodsClassifyMutation) ResetClassifyName() {
	m.classify_name = nil
	delete(m.clearedFields, goodsclassify.FieldClassifyName)
}

// SetClassifyCode sets the "classify_code" field.
func (m *GoodsClassifyMutation) SetClassifyCode(s string) {
	m.classify_code = &s
}

// ClassifyCode returns the value of the "classify_code" field in the mutation.
func (m *GoodsClassifyMutation) ClassifyCode() (r string, exists bool) {
	v := m.classify_code
	if v == nil {
		return
	}
	return *v, true
}

// OldClassifyCode returns the old "classify_code" field's value of the GoodsClassify entity.
// If the GoodsClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsClassifyMutation) OldClassifyCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClassifyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClassifyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassifyCode: %w", err)
	}
	return oldValue.ClassifyCode, nil
}

// ClearClassifyCode clears the value of the "classify_code" field.
func (m *GoodsClassifyMutation) ClearClassifyCode() {
	m.classify_code = nil
	m.clearedFields[goodsclassify.FieldClassifyCode] = struct{}{}
}

// ClassifyCodeCleared returns if the "classify_code" field was cleared in this mutation.
func (m *GoodsClassifyMutation) ClassifyCodeCleared() bool {
	_, ok := m.clearedFields[goodsclassify.FieldClassifyCode]
	return ok
}

// ResetClassifyCode resets all changes to the "classify_code" field.
func (m *GoodsClassifyMutation) ResetClassifyCode() {
	m.classify_code = nil
	delete(m.clearedFields, goodsclassify.FieldClassifyCode)
}

// SetPid sets the "pid" field.
func (m *GoodsClassifyMutation) SetPid(i int) {
	m.pid = &i
	m.addpid = nil
}

// Pid returns the value of the "pid" field in the mutation.
func (m *GoodsClassifyMutation) Pid() (r int, exists bool) {
	v := m.pid
	if v == nil {
		return
	}
	return *v, true
}

// OldPid returns the old "pid" field's value of the GoodsClassify entity.
// If the GoodsClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsClassifyMutation) OldPid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPid: %w", err)
	}
	return oldValue.Pid, nil
}

// AddPid adds i to the "pid" field.
func (m *GoodsClassifyMutation) AddPid(i int) {
	if m.addpid != nil {
		*m.addpid += i
	} else {
		m.addpid = &i
	}
}

// AddedPid returns the value that was added to the "pid" field in this mutation.
func (m *GoodsClassifyMutation) AddedPid() (r int, exists bool) {
	v := m.addpid
	if v == nil {
		return
	}
	return *v, true
}

// ClearPid clears the value of the "pid" field.
func (m *GoodsClassifyMutation) ClearPid() {
	m.pid = nil
	m.addpid = nil
	m.clearedFields[goodsclassify.FieldPid] = struct{}{}
}

// PidCleared returns if the "pid" field was cleared in this mutation.
func (m *GoodsClassifyMutation) PidCleared() bool {
	_, ok := m.clearedFields[goodsclassify.FieldPid]
	return ok
}

// ResetPid resets all changes to the "pid" field.
func (m *GoodsClassifyMutation) ResetPid() {
	m.pid = nil
	m.addpid = nil
	delete(m.clearedFields, goodsclassify.FieldPid)
}

// SetLevel sets the "level" field.
func (m *GoodsClassifyMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *GoodsClassifyMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the GoodsClassify entity.
// If the GoodsClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsClassifyMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *GoodsClassifyMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *GoodsClassifyMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *GoodsClassifyMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetSort sets the "sort" field.
func (m *GoodsClassifyMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *GoodsClassifyMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the GoodsClassify entity.
// If the GoodsClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsClassifyMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *GoodsClassifyMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *GoodsClassifyMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *GoodsClassifyMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[goodsclassify.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *GoodsClassifyMutation) SortCleared() bool {
	_, ok := m.clearedFields[goodsclassify.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *GoodsClassifyMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, goodsclassify.FieldSort)
}

// SetIcon sets the "icon" field.
func (m *GoodsClassifyMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *GoodsClassifyMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the GoodsClassify entity.
// If the GoodsClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsClassifyMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *GoodsClassifyMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[goodsclassify.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *GoodsClassifyMutation) IconCleared() bool {
	_, ok := m.clearedFields[goodsclassify.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *GoodsClassifyMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, goodsclassify.FieldIcon)
}

// SetIsDisable sets the "is_disable" field.
func (m *GoodsClassifyMutation) SetIsDisable(b bool) {
	m.is_disable = &b
}

// IsDisable returns the value of the "is_disable" field in the mutation.
func (m *GoodsClassifyMutation) IsDisable() (r bool, exists bool) {
	v := m.is_disable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisable returns the old "is_disable" field's value of the GoodsClassify entity.
// If the GoodsClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsClassifyMutation) OldIsDisable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsDisable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsDisable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisable: %w", err)
	}
	return oldValue.IsDisable, nil
}

// ClearIsDisable clears the value of the "is_disable" field.
func (m *GoodsClassifyMutation) ClearIsDisable() {
	m.is_disable = nil
	m.clearedFields[goodsclassify.FieldIsDisable] = struct{}{}
}

// IsDisableCleared returns if the "is_disable" field was cleared in this mutation.
func (m *GoodsClassifyMutation) IsDisableCleared() bool {
	_, ok := m.clearedFields[goodsclassify.FieldIsDisable]
	return ok
}

// ResetIsDisable resets all changes to the "is_disable" field.
func (m *GoodsClassifyMutation) ResetIsDisable() {
	m.is_disable = nil
	delete(m.clearedFields, goodsclassify.FieldIsDisable)
}

// AddGoodsSpuIDs adds the "goods_spu" edge to the GoodsSpu entity by ids.
func (m *GoodsClassifyMutation) AddGoodsSpuIDs(ids ...int) {
	if m.goods_spu == nil {
		m.goods_spu = make(map[int]struct{})
	}
	for i := range ids {
		m.goods_spu[ids[i]] = struct{}{}
	}
}

// ClearGoodsSpu clears the "goods_spu" edge to the GoodsSpu entity.
func (m *GoodsClassifyMutation) ClearGoodsSpu() {
	m.clearedgoods_spu = true
}

// GoodsSpuCleared reports if the "goods_spu" edge to the GoodsSpu entity was cleared.
func (m *GoodsClassifyMutation) GoodsSpuCleared() bool {
	return m.clearedgoods_spu
}

// RemoveGoodsSpuIDs removes the "goods_spu" edge to the GoodsSpu entity by IDs.
func (m *GoodsClassifyMutation) RemoveGoodsSpuIDs(ids ...int) {
	if m.removedgoods_spu == nil {
		m.removedgoods_spu = make(map[int]struct{})
	}
	for i := range ids {
		m.removedgoods_spu[ids[i]] = struct{}{}
	}
}

// RemovedGoodsSpu returns the removed IDs of the "goods_spu" edge to the GoodsSpu entity.
func (m *GoodsClassifyMutation) RemovedGoodsSpuIDs() (ids []int) {
	for id := range m.removedgoods_spu {
		ids = append(ids, id)
	}
	return
}

// GoodsSpuIDs returns the "goods_spu" edge IDs in the mutation.
func (m *GoodsClassifyMutation) GoodsSpuIDs() (ids []int) {
	for id := range m.goods_spu {
		ids = append(ids, id)
	}
	return
}

// ResetGoodsSpu resets all changes to the "goods_spu" edge.
func (m *GoodsClassifyMutation) ResetGoodsSpu() {
	m.goods_spu = nil
	m.clearedgoods_spu = false
	m.removedgoods_spu = nil
}

// Op returns the operation name.
func (m *GoodsClassifyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodsClassify).
func (m *GoodsClassifyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodsClassifyMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, goodsclassify.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodsclassify.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodsclassify.FieldDeletedAt)
	}
	if m.classify_name != nil {
		fields = append(fields, goodsclassify.FieldClassifyName)
	}
	if m.classify_code != nil {
		fields = append(fields, goodsclassify.FieldClassifyCode)
	}
	if m.pid != nil {
		fields = append(fields, goodsclassify.FieldPid)
	}
	if m.level != nil {
		fields = append(fields, goodsclassify.FieldLevel)
	}
	if m.sort != nil {
		fields = append(fields, goodsclassify.FieldSort)
	}
	if m.icon != nil {
		fields = append(fields, goodsclassify.FieldIcon)
	}
	if m.is_disable != nil {
		fields = append(fields, goodsclassify.FieldIsDisable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodsClassifyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodsclassify.FieldCreatedAt:
		return m.CreatedAt()
	case goodsclassify.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodsclassify.FieldDeletedAt:
		return m.DeletedAt()
	case goodsclassify.FieldClassifyName:
		return m.ClassifyName()
	case goodsclassify.FieldClassifyCode:
		return m.ClassifyCode()
	case goodsclassify.FieldPid:
		return m.Pid()
	case goodsclassify.FieldLevel:
		return m.Level()
	case goodsclassify.FieldSort:
		return m.Sort()
	case goodsclassify.FieldIcon:
		return m.Icon()
	case goodsclassify.FieldIsDisable:
		return m.IsDisable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodsClassifyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodsclassify.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodsclassify.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodsclassify.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodsclassify.FieldClassifyName:
		return m.OldClassifyName(ctx)
	case goodsclassify.FieldClassifyCode:
		return m.OldClassifyCode(ctx)
	case goodsclassify.FieldPid:
		return m.OldPid(ctx)
	case goodsclassify.FieldLevel:
		return m.OldLevel(ctx)
	case goodsclassify.FieldSort:
		return m.OldSort(ctx)
	case goodsclassify.FieldIcon:
		return m.OldIcon(ctx)
	case goodsclassify.FieldIsDisable:
		return m.OldIsDisable(ctx)
	}
	return nil, fmt.Errorf("unknown GoodsClassify field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodsClassifyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodsclassify.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodsclassify.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodsclassify.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodsclassify.FieldClassifyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassifyName(v)
		return nil
	case goodsclassify.FieldClassifyCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassifyCode(v)
		return nil
	case goodsclassify.FieldPid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	case goodsclassify.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case goodsclassify.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case goodsclassify.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case goodsclassify.FieldIsDisable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisable(v)
		return nil
	}
	return fmt.Errorf("unknown GoodsClassify field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodsClassifyMutation) AddedFields() []string {
	var fields []string
	if m.addpid != nil {
		fields = append(fields, goodsclassify.FieldPid)
	}
	if m.addlevel != nil {
		fields = append(fields, goodsclassify.FieldLevel)
	}
	if m.addsort != nil {
		fields = append(fields, goodsclassify.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodsClassifyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodsclassify.FieldPid:
		return m.AddedPid()
	case goodsclassify.FieldLevel:
		return m.AddedLevel()
	case goodsclassify.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodsClassifyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodsclassify.FieldPid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPid(v)
		return nil
	case goodsclassify.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case goodsclassify.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown GoodsClassify numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodsClassifyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodsclassify.FieldUpdatedAt) {
		fields = append(fields, goodsclassify.FieldUpdatedAt)
	}
	if m.FieldCleared(goodsclassify.FieldDeletedAt) {
		fields = append(fields, goodsclassify.FieldDeletedAt)
	}
	if m.FieldCleared(goodsclassify.FieldClassifyName) {
		fields = append(fields, goodsclassify.FieldClassifyName)
	}
	if m.FieldCleared(goodsclassify.FieldClassifyCode) {
		fields = append(fields, goodsclassify.FieldClassifyCode)
	}
	if m.FieldCleared(goodsclassify.FieldPid) {
		fields = append(fields, goodsclassify.FieldPid)
	}
	if m.FieldCleared(goodsclassify.FieldSort) {
		fields = append(fields, goodsclassify.FieldSort)
	}
	if m.FieldCleared(goodsclassify.FieldIcon) {
		fields = append(fields, goodsclassify.FieldIcon)
	}
	if m.FieldCleared(goodsclassify.FieldIsDisable) {
		fields = append(fields, goodsclassify.FieldIsDisable)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodsClassifyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodsClassifyMutation) ClearField(name string) error {
	switch name {
	case goodsclassify.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case goodsclassify.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case goodsclassify.FieldClassifyName:
		m.ClearClassifyName()
		return nil
	case goodsclassify.FieldClassifyCode:
		m.ClearClassifyCode()
		return nil
	case goodsclassify.FieldPid:
		m.ClearPid()
		return nil
	case goodsclassify.FieldSort:
		m.ClearSort()
		return nil
	case goodsclassify.FieldIcon:
		m.ClearIcon()
		return nil
	case goodsclassify.FieldIsDisable:
		m.ClearIsDisable()
		return nil
	}
	return fmt.Errorf("unknown GoodsClassify nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodsClassifyMutation) ResetField(name string) error {
	switch name {
	case goodsclassify.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodsclassify.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodsclassify.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodsclassify.FieldClassifyName:
		m.ResetClassifyName()
		return nil
	case goodsclassify.FieldClassifyCode:
		m.ResetClassifyCode()
		return nil
	case goodsclassify.FieldPid:
		m.ResetPid()
		return nil
	case goodsclassify.FieldLevel:
		m.ResetLevel()
		return nil
	case goodsclassify.FieldSort:
		m.ResetSort()
		return nil
	case goodsclassify.FieldIcon:
		m.ResetIcon()
		return nil
	case goodsclassify.FieldIsDisable:
		m.ResetIsDisable()
		return nil
	}
	return fmt.Errorf("unknown GoodsClassify field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodsClassifyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.goods_spu != nil {
		edges = append(edges, goodsclassify.EdgeGoodsSpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodsClassifyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case goodsclassify.EdgeGoodsSpu:
		ids := make([]ent.Value, 0, len(m.goods_spu))
		for id := range m.goods_spu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodsClassifyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgoods_spu != nil {
		edges = append(edges, goodsclassify.EdgeGoodsSpu)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodsClassifyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case goodsclassify.EdgeGoodsSpu:
		ids := make([]ent.Value, 0, len(m.removedgoods_spu))
		for id := range m.removedgoods_spu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodsClassifyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgoods_spu {
		edges = append(edges, goodsclassify.EdgeGoodsSpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodsClassifyMutation) EdgeCleared(name string) bool {
	switch name {
	case goodsclassify.EdgeGoodsSpu:
		return m.clearedgoods_spu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodsClassifyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown GoodsClassify unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodsClassifyMutation) ResetEdge(name string) error {
	switch name {
	case goodsclassify.EdgeGoodsSpu:
		m.ResetGoodsSpu()
		return nil
	}
	return fmt.Errorf("unknown GoodsClassify edge %s", name)
}

// GoodsSkuMutation represents an operation that mutates the GoodsSku nodes in the graph.
type GoodsSkuMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	sku_name                  *string
	sku_code                  *string
	stock_num                 *int
	addstock_num              *int
	sales_num                 *int
	addsales_num              *int
	price                     *int
	addprice                  *int
	clearedFields             map[string]struct{}
	goods_spu                 *int
	clearedgoods_spu          bool
	goods_specs_option        map[int]struct{}
	removedgoods_specs_option map[int]struct{}
	clearedgoods_specs_option bool
	done                      bool
	oldValue                  func(context.Context) (*GoodsSku, error)
	predicates                []predicate.GoodsSku
}

var _ ent.Mutation = (*GoodsSkuMutation)(nil)

// goodsskuOption allows management of the mutation configuration using functional options.
type goodsskuOption func(*GoodsSkuMutation)

// newGoodsSkuMutation creates new mutation for the GoodsSku entity.
func newGoodsSkuMutation(c config, op Op, opts ...goodsskuOption) *GoodsSkuMutation {
	m := &GoodsSkuMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodsSku,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodsSkuID sets the ID field of the mutation.
func withGoodsSkuID(id int) goodsskuOption {
	return func(m *GoodsSkuMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodsSku
		)
		m.oldValue = func(ctx context.Context) (*GoodsSku, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodsSku.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodsSku sets the old GoodsSku of the mutation.
func withGoodsSku(node *GoodsSku) goodsskuOption {
	return func(m *GoodsSkuMutation) {
		m.oldValue = func(context.Context) (*GoodsSku, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodsSkuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodsSkuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *GoodsSkuMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodsSkuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodsSkuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodsSku entity.
// If the GoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSkuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodsSkuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodsSkuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodsSkuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodsSku entity.
// If the GoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSkuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *GoodsSkuMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[goodssku.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *GoodsSkuMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[goodssku.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodsSkuMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, goodssku.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodsSkuMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodsSkuMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodsSku entity.
// If the GoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSkuMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GoodsSkuMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[goodssku.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GoodsSkuMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[goodssku.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodsSkuMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, goodssku.FieldDeletedAt)
}

// SetSkuName sets the "sku_name" field.
func (m *GoodsSkuMutation) SetSkuName(s string) {
	m.sku_name = &s
}

// SkuName returns the value of the "sku_name" field in the mutation.
func (m *GoodsSkuMutation) SkuName() (r string, exists bool) {
	v := m.sku_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSkuName returns the old "sku_name" field's value of the GoodsSku entity.
// If the GoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSkuMutation) OldSkuName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSkuName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSkuName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkuName: %w", err)
	}
	return oldValue.SkuName, nil
}

// ResetSkuName resets all changes to the "sku_name" field.
func (m *GoodsSkuMutation) ResetSkuName() {
	m.sku_name = nil
}

// SetSkuCode sets the "sku_code" field.
func (m *GoodsSkuMutation) SetSkuCode(s string) {
	m.sku_code = &s
}

// SkuCode returns the value of the "sku_code" field in the mutation.
func (m *GoodsSkuMutation) SkuCode() (r string, exists bool) {
	v := m.sku_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSkuCode returns the old "sku_code" field's value of the GoodsSku entity.
// If the GoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSkuMutation) OldSkuCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSkuCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSkuCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkuCode: %w", err)
	}
	return oldValue.SkuCode, nil
}

// ResetSkuCode resets all changes to the "sku_code" field.
func (m *GoodsSkuMutation) ResetSkuCode() {
	m.sku_code = nil
}

// SetStockNum sets the "stock_num" field.
func (m *GoodsSkuMutation) SetStockNum(i int) {
	m.stock_num = &i
	m.addstock_num = nil
}

// StockNum returns the value of the "stock_num" field in the mutation.
func (m *GoodsSkuMutation) StockNum() (r int, exists bool) {
	v := m.stock_num
	if v == nil {
		return
	}
	return *v, true
}

// OldStockNum returns the old "stock_num" field's value of the GoodsSku entity.
// If the GoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSkuMutation) OldStockNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStockNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStockNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStockNum: %w", err)
	}
	return oldValue.StockNum, nil
}

// AddStockNum adds i to the "stock_num" field.
func (m *GoodsSkuMutation) AddStockNum(i int) {
	if m.addstock_num != nil {
		*m.addstock_num += i
	} else {
		m.addstock_num = &i
	}
}

// AddedStockNum returns the value that was added to the "stock_num" field in this mutation.
func (m *GoodsSkuMutation) AddedStockNum() (r int, exists bool) {
	v := m.addstock_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetStockNum resets all changes to the "stock_num" field.
func (m *GoodsSkuMutation) ResetStockNum() {
	m.stock_num = nil
	m.addstock_num = nil
}

// SetSalesNum sets the "sales_num" field.
func (m *GoodsSkuMutation) SetSalesNum(i int) {
	m.sales_num = &i
	m.addsales_num = nil
}

// SalesNum returns the value of the "sales_num" field in the mutation.
func (m *GoodsSkuMutation) SalesNum() (r int, exists bool) {
	v := m.sales_num
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesNum returns the old "sales_num" field's value of the GoodsSku entity.
// If the GoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSkuMutation) OldSalesNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSalesNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSalesNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesNum: %w", err)
	}
	return oldValue.SalesNum, nil
}

// AddSalesNum adds i to the "sales_num" field.
func (m *GoodsSkuMutation) AddSalesNum(i int) {
	if m.addsales_num != nil {
		*m.addsales_num += i
	} else {
		m.addsales_num = &i
	}
}

// AddedSalesNum returns the value that was added to the "sales_num" field in this mutation.
func (m *GoodsSkuMutation) AddedSalesNum() (r int, exists bool) {
	v := m.addsales_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetSalesNum resets all changes to the "sales_num" field.
func (m *GoodsSkuMutation) ResetSalesNum() {
	m.sales_num = nil
	m.addsales_num = nil
}

// SetPrice sets the "price" field.
func (m *GoodsSkuMutation) SetPrice(i int) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *GoodsSkuMutation) Price() (r int, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the GoodsSku entity.
// If the GoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSkuMutation) OldPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *GoodsSkuMutation) AddPrice(i int) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *GoodsSkuMutation) AddedPrice() (r int, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *GoodsSkuMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetGoodsSpuID sets the "goods_spu" edge to the GoodsSpu entity by id.
func (m *GoodsSkuMutation) SetGoodsSpuID(id int) {
	m.goods_spu = &id
}

// ClearGoodsSpu clears the "goods_spu" edge to the GoodsSpu entity.
func (m *GoodsSkuMutation) ClearGoodsSpu() {
	m.clearedgoods_spu = true
}

// GoodsSpuCleared reports if the "goods_spu" edge to the GoodsSpu entity was cleared.
func (m *GoodsSkuMutation) GoodsSpuCleared() bool {
	return m.clearedgoods_spu
}

// GoodsSpuID returns the "goods_spu" edge ID in the mutation.
func (m *GoodsSkuMutation) GoodsSpuID() (id int, exists bool) {
	if m.goods_spu != nil {
		return *m.goods_spu, true
	}
	return
}

// GoodsSpuIDs returns the "goods_spu" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GoodsSpuID instead. It exists only for internal usage by the builders.
func (m *GoodsSkuMutation) GoodsSpuIDs() (ids []int) {
	if id := m.goods_spu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGoodsSpu resets all changes to the "goods_spu" edge.
func (m *GoodsSkuMutation) ResetGoodsSpu() {
	m.goods_spu = nil
	m.clearedgoods_spu = false
}

// AddGoodsSpecsOptionIDs adds the "goods_specs_option" edge to the GoodsSpecsOption entity by ids.
func (m *GoodsSkuMutation) AddGoodsSpecsOptionIDs(ids ...int) {
	if m.goods_specs_option == nil {
		m.goods_specs_option = make(map[int]struct{})
	}
	for i := range ids {
		m.goods_specs_option[ids[i]] = struct{}{}
	}
}

// ClearGoodsSpecsOption clears the "goods_specs_option" edge to the GoodsSpecsOption entity.
func (m *GoodsSkuMutation) ClearGoodsSpecsOption() {
	m.clearedgoods_specs_option = true
}

// GoodsSpecsOptionCleared reports if the "goods_specs_option" edge to the GoodsSpecsOption entity was cleared.
func (m *GoodsSkuMutation) GoodsSpecsOptionCleared() bool {
	return m.clearedgoods_specs_option
}

// RemoveGoodsSpecsOptionIDs removes the "goods_specs_option" edge to the GoodsSpecsOption entity by IDs.
func (m *GoodsSkuMutation) RemoveGoodsSpecsOptionIDs(ids ...int) {
	if m.removedgoods_specs_option == nil {
		m.removedgoods_specs_option = make(map[int]struct{})
	}
	for i := range ids {
		m.removedgoods_specs_option[ids[i]] = struct{}{}
	}
}

// RemovedGoodsSpecsOption returns the removed IDs of the "goods_specs_option" edge to the GoodsSpecsOption entity.
func (m *GoodsSkuMutation) RemovedGoodsSpecsOptionIDs() (ids []int) {
	for id := range m.removedgoods_specs_option {
		ids = append(ids, id)
	}
	return
}

// GoodsSpecsOptionIDs returns the "goods_specs_option" edge IDs in the mutation.
func (m *GoodsSkuMutation) GoodsSpecsOptionIDs() (ids []int) {
	for id := range m.goods_specs_option {
		ids = append(ids, id)
	}
	return
}

// ResetGoodsSpecsOption resets all changes to the "goods_specs_option" edge.
func (m *GoodsSkuMutation) ResetGoodsSpecsOption() {
	m.goods_specs_option = nil
	m.clearedgoods_specs_option = false
	m.removedgoods_specs_option = nil
}

// Op returns the operation name.
func (m *GoodsSkuMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodsSku).
func (m *GoodsSkuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodsSkuMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, goodssku.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodssku.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodssku.FieldDeletedAt)
	}
	if m.sku_name != nil {
		fields = append(fields, goodssku.FieldSkuName)
	}
	if m.sku_code != nil {
		fields = append(fields, goodssku.FieldSkuCode)
	}
	if m.stock_num != nil {
		fields = append(fields, goodssku.FieldStockNum)
	}
	if m.sales_num != nil {
		fields = append(fields, goodssku.FieldSalesNum)
	}
	if m.price != nil {
		fields = append(fields, goodssku.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodsSkuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodssku.FieldCreatedAt:
		return m.CreatedAt()
	case goodssku.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodssku.FieldDeletedAt:
		return m.DeletedAt()
	case goodssku.FieldSkuName:
		return m.SkuName()
	case goodssku.FieldSkuCode:
		return m.SkuCode()
	case goodssku.FieldStockNum:
		return m.StockNum()
	case goodssku.FieldSalesNum:
		return m.SalesNum()
	case goodssku.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodsSkuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodssku.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodssku.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodssku.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodssku.FieldSkuName:
		return m.OldSkuName(ctx)
	case goodssku.FieldSkuCode:
		return m.OldSkuCode(ctx)
	case goodssku.FieldStockNum:
		return m.OldStockNum(ctx)
	case goodssku.FieldSalesNum:
		return m.OldSalesNum(ctx)
	case goodssku.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown GoodsSku field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodsSkuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodssku.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodssku.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodssku.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodssku.FieldSkuName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkuName(v)
		return nil
	case goodssku.FieldSkuCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkuCode(v)
		return nil
	case goodssku.FieldStockNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStockNum(v)
		return nil
	case goodssku.FieldSalesNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesNum(v)
		return nil
	case goodssku.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown GoodsSku field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodsSkuMutation) AddedFields() []string {
	var fields []string
	if m.addstock_num != nil {
		fields = append(fields, goodssku.FieldStockNum)
	}
	if m.addsales_num != nil {
		fields = append(fields, goodssku.FieldSalesNum)
	}
	if m.addprice != nil {
		fields = append(fields, goodssku.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodsSkuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodssku.FieldStockNum:
		return m.AddedStockNum()
	case goodssku.FieldSalesNum:
		return m.AddedSalesNum()
	case goodssku.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodsSkuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodssku.FieldStockNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStockNum(v)
		return nil
	case goodssku.FieldSalesNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalesNum(v)
		return nil
	case goodssku.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown GoodsSku numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodsSkuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodssku.FieldUpdatedAt) {
		fields = append(fields, goodssku.FieldUpdatedAt)
	}
	if m.FieldCleared(goodssku.FieldDeletedAt) {
		fields = append(fields, goodssku.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodsSkuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodsSkuMutation) ClearField(name string) error {
	switch name {
	case goodssku.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case goodssku.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown GoodsSku nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodsSkuMutation) ResetField(name string) error {
	switch name {
	case goodssku.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodssku.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodssku.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodssku.FieldSkuName:
		m.ResetSkuName()
		return nil
	case goodssku.FieldSkuCode:
		m.ResetSkuCode()
		return nil
	case goodssku.FieldStockNum:
		m.ResetStockNum()
		return nil
	case goodssku.FieldSalesNum:
		m.ResetSalesNum()
		return nil
	case goodssku.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown GoodsSku field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodsSkuMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.goods_spu != nil {
		edges = append(edges, goodssku.EdgeGoodsSpu)
	}
	if m.goods_specs_option != nil {
		edges = append(edges, goodssku.EdgeGoodsSpecsOption)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodsSkuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case goodssku.EdgeGoodsSpu:
		if id := m.goods_spu; id != nil {
			return []ent.Value{*id}
		}
	case goodssku.EdgeGoodsSpecsOption:
		ids := make([]ent.Value, 0, len(m.goods_specs_option))
		for id := range m.goods_specs_option {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodsSkuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedgoods_specs_option != nil {
		edges = append(edges, goodssku.EdgeGoodsSpecsOption)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodsSkuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case goodssku.EdgeGoodsSpecsOption:
		ids := make([]ent.Value, 0, len(m.removedgoods_specs_option))
		for id := range m.removedgoods_specs_option {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodsSkuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgoods_spu {
		edges = append(edges, goodssku.EdgeGoodsSpu)
	}
	if m.clearedgoods_specs_option {
		edges = append(edges, goodssku.EdgeGoodsSpecsOption)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodsSkuMutation) EdgeCleared(name string) bool {
	switch name {
	case goodssku.EdgeGoodsSpu:
		return m.clearedgoods_spu
	case goodssku.EdgeGoodsSpecsOption:
		return m.clearedgoods_specs_option
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodsSkuMutation) ClearEdge(name string) error {
	switch name {
	case goodssku.EdgeGoodsSpu:
		m.ClearGoodsSpu()
		return nil
	}
	return fmt.Errorf("unknown GoodsSku unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodsSkuMutation) ResetEdge(name string) error {
	switch name {
	case goodssku.EdgeGoodsSpu:
		m.ResetGoodsSpu()
		return nil
	case goodssku.EdgeGoodsSpecsOption:
		m.ResetGoodsSpecsOption()
		return nil
	}
	return fmt.Errorf("unknown GoodsSku edge %s", name)
}

// GoodsSpecsMutation represents an operation that mutates the GoodsSpecs nodes in the graph.
type GoodsSpecsMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	specs_name                *string
	clearedFields             map[string]struct{}
	goods_specs_option        map[int]struct{}
	removedgoods_specs_option map[int]struct{}
	clearedgoods_specs_option bool
	done                      bool
	oldValue                  func(context.Context) (*GoodsSpecs, error)
	predicates                []predicate.GoodsSpecs
}

var _ ent.Mutation = (*GoodsSpecsMutation)(nil)

// goodsspecsOption allows management of the mutation configuration using functional options.
type goodsspecsOption func(*GoodsSpecsMutation)

// newGoodsSpecsMutation creates new mutation for the GoodsSpecs entity.
func newGoodsSpecsMutation(c config, op Op, opts ...goodsspecsOption) *GoodsSpecsMutation {
	m := &GoodsSpecsMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodsSpecs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodsSpecsID sets the ID field of the mutation.
func withGoodsSpecsID(id int) goodsspecsOption {
	return func(m *GoodsSpecsMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodsSpecs
		)
		m.oldValue = func(ctx context.Context) (*GoodsSpecs, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodsSpecs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodsSpecs sets the old GoodsSpecs of the mutation.
func withGoodsSpecs(node *GoodsSpecs) goodsspecsOption {
	return func(m *GoodsSpecsMutation) {
		m.oldValue = func(context.Context) (*GoodsSpecs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodsSpecsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodsSpecsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *GoodsSpecsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodsSpecsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodsSpecsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodsSpecs entity.
// If the GoodsSpecs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpecsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodsSpecsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodsSpecsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodsSpecsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodsSpecs entity.
// If the GoodsSpecs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpecsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *GoodsSpecsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[goodsspecs.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *GoodsSpecsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[goodsspecs.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodsSpecsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, goodsspecs.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodsSpecsMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodsSpecsMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodsSpecs entity.
// If the GoodsSpecs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpecsMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GoodsSpecsMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[goodsspecs.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GoodsSpecsMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[goodsspecs.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodsSpecsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, goodsspecs.FieldDeletedAt)
}

// SetSpecsName sets the "specs_name" field.
func (m *GoodsSpecsMutation) SetSpecsName(s string) {
	m.specs_name = &s
}

// SpecsName returns the value of the "specs_name" field in the mutation.
func (m *GoodsSpecsMutation) SpecsName() (r string, exists bool) {
	v := m.specs_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecsName returns the old "specs_name" field's value of the GoodsSpecs entity.
// If the GoodsSpecs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpecsMutation) OldSpecsName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecsName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecsName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecsName: %w", err)
	}
	return oldValue.SpecsName, nil
}

// ResetSpecsName resets all changes to the "specs_name" field.
func (m *GoodsSpecsMutation) ResetSpecsName() {
	m.specs_name = nil
}

// AddGoodsSpecsOptionIDs adds the "goods_specs_option" edge to the GoodsSpecsOption entity by ids.
func (m *GoodsSpecsMutation) AddGoodsSpecsOptionIDs(ids ...int) {
	if m.goods_specs_option == nil {
		m.goods_specs_option = make(map[int]struct{})
	}
	for i := range ids {
		m.goods_specs_option[ids[i]] = struct{}{}
	}
}

// ClearGoodsSpecsOption clears the "goods_specs_option" edge to the GoodsSpecsOption entity.
func (m *GoodsSpecsMutation) ClearGoodsSpecsOption() {
	m.clearedgoods_specs_option = true
}

// GoodsSpecsOptionCleared reports if the "goods_specs_option" edge to the GoodsSpecsOption entity was cleared.
func (m *GoodsSpecsMutation) GoodsSpecsOptionCleared() bool {
	return m.clearedgoods_specs_option
}

// RemoveGoodsSpecsOptionIDs removes the "goods_specs_option" edge to the GoodsSpecsOption entity by IDs.
func (m *GoodsSpecsMutation) RemoveGoodsSpecsOptionIDs(ids ...int) {
	if m.removedgoods_specs_option == nil {
		m.removedgoods_specs_option = make(map[int]struct{})
	}
	for i := range ids {
		m.removedgoods_specs_option[ids[i]] = struct{}{}
	}
}

// RemovedGoodsSpecsOption returns the removed IDs of the "goods_specs_option" edge to the GoodsSpecsOption entity.
func (m *GoodsSpecsMutation) RemovedGoodsSpecsOptionIDs() (ids []int) {
	for id := range m.removedgoods_specs_option {
		ids = append(ids, id)
	}
	return
}

// GoodsSpecsOptionIDs returns the "goods_specs_option" edge IDs in the mutation.
func (m *GoodsSpecsMutation) GoodsSpecsOptionIDs() (ids []int) {
	for id := range m.goods_specs_option {
		ids = append(ids, id)
	}
	return
}

// ResetGoodsSpecsOption resets all changes to the "goods_specs_option" edge.
func (m *GoodsSpecsMutation) ResetGoodsSpecsOption() {
	m.goods_specs_option = nil
	m.clearedgoods_specs_option = false
	m.removedgoods_specs_option = nil
}

// Op returns the operation name.
func (m *GoodsSpecsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodsSpecs).
func (m *GoodsSpecsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodsSpecsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, goodsspecs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodsspecs.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodsspecs.FieldDeletedAt)
	}
	if m.specs_name != nil {
		fields = append(fields, goodsspecs.FieldSpecsName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodsSpecsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodsspecs.FieldCreatedAt:
		return m.CreatedAt()
	case goodsspecs.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodsspecs.FieldDeletedAt:
		return m.DeletedAt()
	case goodsspecs.FieldSpecsName:
		return m.SpecsName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodsSpecsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodsspecs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodsspecs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodsspecs.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodsspecs.FieldSpecsName:
		return m.OldSpecsName(ctx)
	}
	return nil, fmt.Errorf("unknown GoodsSpecs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodsSpecsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodsspecs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodsspecs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodsspecs.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodsspecs.FieldSpecsName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecsName(v)
		return nil
	}
	return fmt.Errorf("unknown GoodsSpecs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodsSpecsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodsSpecsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodsSpecsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GoodsSpecs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodsSpecsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodsspecs.FieldUpdatedAt) {
		fields = append(fields, goodsspecs.FieldUpdatedAt)
	}
	if m.FieldCleared(goodsspecs.FieldDeletedAt) {
		fields = append(fields, goodsspecs.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodsSpecsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodsSpecsMutation) ClearField(name string) error {
	switch name {
	case goodsspecs.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case goodsspecs.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown GoodsSpecs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodsSpecsMutation) ResetField(name string) error {
	switch name {
	case goodsspecs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodsspecs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodsspecs.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodsspecs.FieldSpecsName:
		m.ResetSpecsName()
		return nil
	}
	return fmt.Errorf("unknown GoodsSpecs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodsSpecsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.goods_specs_option != nil {
		edges = append(edges, goodsspecs.EdgeGoodsSpecsOption)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodsSpecsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case goodsspecs.EdgeGoodsSpecsOption:
		ids := make([]ent.Value, 0, len(m.goods_specs_option))
		for id := range m.goods_specs_option {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodsSpecsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgoods_specs_option != nil {
		edges = append(edges, goodsspecs.EdgeGoodsSpecsOption)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodsSpecsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case goodsspecs.EdgeGoodsSpecsOption:
		ids := make([]ent.Value, 0, len(m.removedgoods_specs_option))
		for id := range m.removedgoods_specs_option {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodsSpecsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgoods_specs_option {
		edges = append(edges, goodsspecs.EdgeGoodsSpecsOption)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodsSpecsMutation) EdgeCleared(name string) bool {
	switch name {
	case goodsspecs.EdgeGoodsSpecsOption:
		return m.clearedgoods_specs_option
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodsSpecsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown GoodsSpecs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodsSpecsMutation) ResetEdge(name string) error {
	switch name {
	case goodsspecs.EdgeGoodsSpecsOption:
		m.ResetGoodsSpecsOption()
		return nil
	}
	return fmt.Errorf("unknown GoodsSpecs edge %s", name)
}

// GoodsSpecsOptionMutation represents an operation that mutates the GoodsSpecsOption nodes in the graph.
type GoodsSpecsOptionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	specs_option_value *string
	clearedFields      map[string]struct{}
	goods_specs        *int
	clearedgoods_specs bool
	goods_sku          map[int]struct{}
	removedgoods_sku   map[int]struct{}
	clearedgoods_sku   bool
	done               bool
	oldValue           func(context.Context) (*GoodsSpecsOption, error)
	predicates         []predicate.GoodsSpecsOption
}

var _ ent.Mutation = (*GoodsSpecsOptionMutation)(nil)

// goodsspecsoptionOption allows management of the mutation configuration using functional options.
type goodsspecsoptionOption func(*GoodsSpecsOptionMutation)

// newGoodsSpecsOptionMutation creates new mutation for the GoodsSpecsOption entity.
func newGoodsSpecsOptionMutation(c config, op Op, opts ...goodsspecsoptionOption) *GoodsSpecsOptionMutation {
	m := &GoodsSpecsOptionMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodsSpecsOption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodsSpecsOptionID sets the ID field of the mutation.
func withGoodsSpecsOptionID(id int) goodsspecsoptionOption {
	return func(m *GoodsSpecsOptionMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodsSpecsOption
		)
		m.oldValue = func(ctx context.Context) (*GoodsSpecsOption, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodsSpecsOption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodsSpecsOption sets the old GoodsSpecsOption of the mutation.
func withGoodsSpecsOption(node *GoodsSpecsOption) goodsspecsoptionOption {
	return func(m *GoodsSpecsOptionMutation) {
		m.oldValue = func(context.Context) (*GoodsSpecsOption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodsSpecsOptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodsSpecsOptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *GoodsSpecsOptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodsSpecsOptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodsSpecsOptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodsSpecsOption entity.
// If the GoodsSpecsOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpecsOptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodsSpecsOptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodsSpecsOptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodsSpecsOptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodsSpecsOption entity.
// If the GoodsSpecsOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpecsOptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *GoodsSpecsOptionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[goodsspecsoption.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *GoodsSpecsOptionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[goodsspecsoption.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodsSpecsOptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, goodsspecsoption.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodsSpecsOptionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodsSpecsOptionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodsSpecsOption entity.
// If the GoodsSpecsOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpecsOptionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GoodsSpecsOptionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[goodsspecsoption.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GoodsSpecsOptionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[goodsspecsoption.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodsSpecsOptionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, goodsspecsoption.FieldDeletedAt)
}

// SetSpecsOptionValue sets the "specs_option_value" field.
func (m *GoodsSpecsOptionMutation) SetSpecsOptionValue(s string) {
	m.specs_option_value = &s
}

// SpecsOptionValue returns the value of the "specs_option_value" field in the mutation.
func (m *GoodsSpecsOptionMutation) SpecsOptionValue() (r string, exists bool) {
	v := m.specs_option_value
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecsOptionValue returns the old "specs_option_value" field's value of the GoodsSpecsOption entity.
// If the GoodsSpecsOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpecsOptionMutation) OldSpecsOptionValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecsOptionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecsOptionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecsOptionValue: %w", err)
	}
	return oldValue.SpecsOptionValue, nil
}

// ResetSpecsOptionValue resets all changes to the "specs_option_value" field.
func (m *GoodsSpecsOptionMutation) ResetSpecsOptionValue() {
	m.specs_option_value = nil
}

// SetGoodsSpecsID sets the "goods_specs" edge to the GoodsSpecs entity by id.
func (m *GoodsSpecsOptionMutation) SetGoodsSpecsID(id int) {
	m.goods_specs = &id
}

// ClearGoodsSpecs clears the "goods_specs" edge to the GoodsSpecs entity.
func (m *GoodsSpecsOptionMutation) ClearGoodsSpecs() {
	m.clearedgoods_specs = true
}

// GoodsSpecsCleared reports if the "goods_specs" edge to the GoodsSpecs entity was cleared.
func (m *GoodsSpecsOptionMutation) GoodsSpecsCleared() bool {
	return m.clearedgoods_specs
}

// GoodsSpecsID returns the "goods_specs" edge ID in the mutation.
func (m *GoodsSpecsOptionMutation) GoodsSpecsID() (id int, exists bool) {
	if m.goods_specs != nil {
		return *m.goods_specs, true
	}
	return
}

// GoodsSpecsIDs returns the "goods_specs" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GoodsSpecsID instead. It exists only for internal usage by the builders.
func (m *GoodsSpecsOptionMutation) GoodsSpecsIDs() (ids []int) {
	if id := m.goods_specs; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGoodsSpecs resets all changes to the "goods_specs" edge.
func (m *GoodsSpecsOptionMutation) ResetGoodsSpecs() {
	m.goods_specs = nil
	m.clearedgoods_specs = false
}

// AddGoodsSkuIDs adds the "goods_sku" edge to the GoodsSku entity by ids.
func (m *GoodsSpecsOptionMutation) AddGoodsSkuIDs(ids ...int) {
	if m.goods_sku == nil {
		m.goods_sku = make(map[int]struct{})
	}
	for i := range ids {
		m.goods_sku[ids[i]] = struct{}{}
	}
}

// ClearGoodsSku clears the "goods_sku" edge to the GoodsSku entity.
func (m *GoodsSpecsOptionMutation) ClearGoodsSku() {
	m.clearedgoods_sku = true
}

// GoodsSkuCleared reports if the "goods_sku" edge to the GoodsSku entity was cleared.
func (m *GoodsSpecsOptionMutation) GoodsSkuCleared() bool {
	return m.clearedgoods_sku
}

// RemoveGoodsSkuIDs removes the "goods_sku" edge to the GoodsSku entity by IDs.
func (m *GoodsSpecsOptionMutation) RemoveGoodsSkuIDs(ids ...int) {
	if m.removedgoods_sku == nil {
		m.removedgoods_sku = make(map[int]struct{})
	}
	for i := range ids {
		m.removedgoods_sku[ids[i]] = struct{}{}
	}
}

// RemovedGoodsSku returns the removed IDs of the "goods_sku" edge to the GoodsSku entity.
func (m *GoodsSpecsOptionMutation) RemovedGoodsSkuIDs() (ids []int) {
	for id := range m.removedgoods_sku {
		ids = append(ids, id)
	}
	return
}

// GoodsSkuIDs returns the "goods_sku" edge IDs in the mutation.
func (m *GoodsSpecsOptionMutation) GoodsSkuIDs() (ids []int) {
	for id := range m.goods_sku {
		ids = append(ids, id)
	}
	return
}

// ResetGoodsSku resets all changes to the "goods_sku" edge.
func (m *GoodsSpecsOptionMutation) ResetGoodsSku() {
	m.goods_sku = nil
	m.clearedgoods_sku = false
	m.removedgoods_sku = nil
}

// Op returns the operation name.
func (m *GoodsSpecsOptionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodsSpecsOption).
func (m *GoodsSpecsOptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodsSpecsOptionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, goodsspecsoption.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodsspecsoption.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodsspecsoption.FieldDeletedAt)
	}
	if m.specs_option_value != nil {
		fields = append(fields, goodsspecsoption.FieldSpecsOptionValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodsSpecsOptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodsspecsoption.FieldCreatedAt:
		return m.CreatedAt()
	case goodsspecsoption.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodsspecsoption.FieldDeletedAt:
		return m.DeletedAt()
	case goodsspecsoption.FieldSpecsOptionValue:
		return m.SpecsOptionValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodsSpecsOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodsspecsoption.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodsspecsoption.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodsspecsoption.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodsspecsoption.FieldSpecsOptionValue:
		return m.OldSpecsOptionValue(ctx)
	}
	return nil, fmt.Errorf("unknown GoodsSpecsOption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodsSpecsOptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodsspecsoption.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodsspecsoption.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodsspecsoption.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodsspecsoption.FieldSpecsOptionValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecsOptionValue(v)
		return nil
	}
	return fmt.Errorf("unknown GoodsSpecsOption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodsSpecsOptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodsSpecsOptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodsSpecsOptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GoodsSpecsOption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodsSpecsOptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodsspecsoption.FieldUpdatedAt) {
		fields = append(fields, goodsspecsoption.FieldUpdatedAt)
	}
	if m.FieldCleared(goodsspecsoption.FieldDeletedAt) {
		fields = append(fields, goodsspecsoption.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodsSpecsOptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodsSpecsOptionMutation) ClearField(name string) error {
	switch name {
	case goodsspecsoption.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case goodsspecsoption.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown GoodsSpecsOption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodsSpecsOptionMutation) ResetField(name string) error {
	switch name {
	case goodsspecsoption.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodsspecsoption.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodsspecsoption.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodsspecsoption.FieldSpecsOptionValue:
		m.ResetSpecsOptionValue()
		return nil
	}
	return fmt.Errorf("unknown GoodsSpecsOption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodsSpecsOptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.goods_specs != nil {
		edges = append(edges, goodsspecsoption.EdgeGoodsSpecs)
	}
	if m.goods_sku != nil {
		edges = append(edges, goodsspecsoption.EdgeGoodsSku)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodsSpecsOptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case goodsspecsoption.EdgeGoodsSpecs:
		if id := m.goods_specs; id != nil {
			return []ent.Value{*id}
		}
	case goodsspecsoption.EdgeGoodsSku:
		ids := make([]ent.Value, 0, len(m.goods_sku))
		for id := range m.goods_sku {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodsSpecsOptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedgoods_sku != nil {
		edges = append(edges, goodsspecsoption.EdgeGoodsSku)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodsSpecsOptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case goodsspecsoption.EdgeGoodsSku:
		ids := make([]ent.Value, 0, len(m.removedgoods_sku))
		for id := range m.removedgoods_sku {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodsSpecsOptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgoods_specs {
		edges = append(edges, goodsspecsoption.EdgeGoodsSpecs)
	}
	if m.clearedgoods_sku {
		edges = append(edges, goodsspecsoption.EdgeGoodsSku)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodsSpecsOptionMutation) EdgeCleared(name string) bool {
	switch name {
	case goodsspecsoption.EdgeGoodsSpecs:
		return m.clearedgoods_specs
	case goodsspecsoption.EdgeGoodsSku:
		return m.clearedgoods_sku
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodsSpecsOptionMutation) ClearEdge(name string) error {
	switch name {
	case goodsspecsoption.EdgeGoodsSpecs:
		m.ClearGoodsSpecs()
		return nil
	}
	return fmt.Errorf("unknown GoodsSpecsOption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodsSpecsOptionMutation) ResetEdge(name string) error {
	switch name {
	case goodsspecsoption.EdgeGoodsSpecs:
		m.ResetGoodsSpecs()
		return nil
	case goodsspecsoption.EdgeGoodsSku:
		m.ResetGoodsSku()
		return nil
	}
	return fmt.Errorf("unknown GoodsSpecsOption edge %s", name)
}

// GoodsSpuMutation represents an operation that mutates the GoodsSpu nodes in the graph.
type GoodsSpuMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	spu_name               *string
	spu_code               *string
	spu_head_img           *string
	sales_num              *int
	addsales_num           *int
	spu_desc               *string
	spu_details            *string
	is_custom_sku          *bool
	clearedFields          map[string]struct{}
	goods_classify         *int
	clearedgoods_classify  bool
	goods_sku              map[int]struct{}
	removedgoods_sku       map[int]struct{}
	clearedgoods_sku       bool
	order_goods_sku        map[int]struct{}
	removedorder_goods_sku map[int]struct{}
	clearedorder_goods_sku bool
	goods_spu_imgs         map[int]struct{}
	removedgoods_spu_imgs  map[int]struct{}
	clearedgoods_spu_imgs  bool
	done                   bool
	oldValue               func(context.Context) (*GoodsSpu, error)
	predicates             []predicate.GoodsSpu
}

var _ ent.Mutation = (*GoodsSpuMutation)(nil)

// goodsspuOption allows management of the mutation configuration using functional options.
type goodsspuOption func(*GoodsSpuMutation)

// newGoodsSpuMutation creates new mutation for the GoodsSpu entity.
func newGoodsSpuMutation(c config, op Op, opts ...goodsspuOption) *GoodsSpuMutation {
	m := &GoodsSpuMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodsSpu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodsSpuID sets the ID field of the mutation.
func withGoodsSpuID(id int) goodsspuOption {
	return func(m *GoodsSpuMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodsSpu
		)
		m.oldValue = func(ctx context.Context) (*GoodsSpu, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodsSpu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodsSpu sets the old GoodsSpu of the mutation.
func withGoodsSpu(node *GoodsSpu) goodsspuOption {
	return func(m *GoodsSpuMutation) {
		m.oldValue = func(context.Context) (*GoodsSpu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodsSpuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodsSpuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *GoodsSpuMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodsSpuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodsSpuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodsSpu entity.
// If the GoodsSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodsSpuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodsSpuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodsSpuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodsSpu entity.
// If the GoodsSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *GoodsSpuMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[goodsspu.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *GoodsSpuMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[goodsspu.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodsSpuMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, goodsspu.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodsSpuMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodsSpuMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodsSpu entity.
// If the GoodsSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpuMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GoodsSpuMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[goodsspu.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GoodsSpuMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[goodsspu.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodsSpuMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, goodsspu.FieldDeletedAt)
}

// SetSpuName sets the "spu_name" field.
func (m *GoodsSpuMutation) SetSpuName(s string) {
	m.spu_name = &s
}

// SpuName returns the value of the "spu_name" field in the mutation.
func (m *GoodsSpuMutation) SpuName() (r string, exists bool) {
	v := m.spu_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuName returns the old "spu_name" field's value of the GoodsSpu entity.
// If the GoodsSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpuMutation) OldSpuName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuName: %w", err)
	}
	return oldValue.SpuName, nil
}

// ResetSpuName resets all changes to the "spu_name" field.
func (m *GoodsSpuMutation) ResetSpuName() {
	m.spu_name = nil
}

// SetSpuCode sets the "spu_code" field.
func (m *GoodsSpuMutation) SetSpuCode(s string) {
	m.spu_code = &s
}

// SpuCode returns the value of the "spu_code" field in the mutation.
func (m *GoodsSpuMutation) SpuCode() (r string, exists bool) {
	v := m.spu_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuCode returns the old "spu_code" field's value of the GoodsSpu entity.
// If the GoodsSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpuMutation) OldSpuCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuCode: %w", err)
	}
	return oldValue.SpuCode, nil
}

// ResetSpuCode resets all changes to the "spu_code" field.
func (m *GoodsSpuMutation) ResetSpuCode() {
	m.spu_code = nil
}

// SetSpuHeadImg sets the "spu_head_img" field.
func (m *GoodsSpuMutation) SetSpuHeadImg(s string) {
	m.spu_head_img = &s
}

// SpuHeadImg returns the value of the "spu_head_img" field in the mutation.
func (m *GoodsSpuMutation) SpuHeadImg() (r string, exists bool) {
	v := m.spu_head_img
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuHeadImg returns the old "spu_head_img" field's value of the GoodsSpu entity.
// If the GoodsSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpuMutation) OldSpuHeadImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuHeadImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuHeadImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuHeadImg: %w", err)
	}
	return oldValue.SpuHeadImg, nil
}

// ClearSpuHeadImg clears the value of the "spu_head_img" field.
func (m *GoodsSpuMutation) ClearSpuHeadImg() {
	m.spu_head_img = nil
	m.clearedFields[goodsspu.FieldSpuHeadImg] = struct{}{}
}

// SpuHeadImgCleared returns if the "spu_head_img" field was cleared in this mutation.
func (m *GoodsSpuMutation) SpuHeadImgCleared() bool {
	_, ok := m.clearedFields[goodsspu.FieldSpuHeadImg]
	return ok
}

// ResetSpuHeadImg resets all changes to the "spu_head_img" field.
func (m *GoodsSpuMutation) ResetSpuHeadImg() {
	m.spu_head_img = nil
	delete(m.clearedFields, goodsspu.FieldSpuHeadImg)
}

// SetSalesNum sets the "sales_num" field.
func (m *GoodsSpuMutation) SetSalesNum(i int) {
	m.sales_num = &i
	m.addsales_num = nil
}

// SalesNum returns the value of the "sales_num" field in the mutation.
func (m *GoodsSpuMutation) SalesNum() (r int, exists bool) {
	v := m.sales_num
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesNum returns the old "sales_num" field's value of the GoodsSpu entity.
// If the GoodsSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpuMutation) OldSalesNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSalesNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSalesNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesNum: %w", err)
	}
	return oldValue.SalesNum, nil
}

// AddSalesNum adds i to the "sales_num" field.
func (m *GoodsSpuMutation) AddSalesNum(i int) {
	if m.addsales_num != nil {
		*m.addsales_num += i
	} else {
		m.addsales_num = &i
	}
}

// AddedSalesNum returns the value that was added to the "sales_num" field in this mutation.
func (m *GoodsSpuMutation) AddedSalesNum() (r int, exists bool) {
	v := m.addsales_num
	if v == nil {
		return
	}
	return *v, true
}

// ClearSalesNum clears the value of the "sales_num" field.
func (m *GoodsSpuMutation) ClearSalesNum() {
	m.sales_num = nil
	m.addsales_num = nil
	m.clearedFields[goodsspu.FieldSalesNum] = struct{}{}
}

// SalesNumCleared returns if the "sales_num" field was cleared in this mutation.
func (m *GoodsSpuMutation) SalesNumCleared() bool {
	_, ok := m.clearedFields[goodsspu.FieldSalesNum]
	return ok
}

// ResetSalesNum resets all changes to the "sales_num" field.
func (m *GoodsSpuMutation) ResetSalesNum() {
	m.sales_num = nil
	m.addsales_num = nil
	delete(m.clearedFields, goodsspu.FieldSalesNum)
}

// SetSpuDesc sets the "spu_desc" field.
func (m *GoodsSpuMutation) SetSpuDesc(s string) {
	m.spu_desc = &s
}

// SpuDesc returns the value of the "spu_desc" field in the mutation.
func (m *GoodsSpuMutation) SpuDesc() (r string, exists bool) {
	v := m.spu_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuDesc returns the old "spu_desc" field's value of the GoodsSpu entity.
// If the GoodsSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpuMutation) OldSpuDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuDesc: %w", err)
	}
	return oldValue.SpuDesc, nil
}

// ClearSpuDesc clears the value of the "spu_desc" field.
func (m *GoodsSpuMutation) ClearSpuDesc() {
	m.spu_desc = nil
	m.clearedFields[goodsspu.FieldSpuDesc] = struct{}{}
}

// SpuDescCleared returns if the "spu_desc" field was cleared in this mutation.
func (m *GoodsSpuMutation) SpuDescCleared() bool {
	_, ok := m.clearedFields[goodsspu.FieldSpuDesc]
	return ok
}

// ResetSpuDesc resets all changes to the "spu_desc" field.
func (m *GoodsSpuMutation) ResetSpuDesc() {
	m.spu_desc = nil
	delete(m.clearedFields, goodsspu.FieldSpuDesc)
}

// SetSpuDetails sets the "spu_details" field.
func (m *GoodsSpuMutation) SetSpuDetails(s string) {
	m.spu_details = &s
}

// SpuDetails returns the value of the "spu_details" field in the mutation.
func (m *GoodsSpuMutation) SpuDetails() (r string, exists bool) {
	v := m.spu_details
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuDetails returns the old "spu_details" field's value of the GoodsSpu entity.
// If the GoodsSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpuMutation) OldSpuDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuDetails: %w", err)
	}
	return oldValue.SpuDetails, nil
}

// ClearSpuDetails clears the value of the "spu_details" field.
func (m *GoodsSpuMutation) ClearSpuDetails() {
	m.spu_details = nil
	m.clearedFields[goodsspu.FieldSpuDetails] = struct{}{}
}

// SpuDetailsCleared returns if the "spu_details" field was cleared in this mutation.
func (m *GoodsSpuMutation) SpuDetailsCleared() bool {
	_, ok := m.clearedFields[goodsspu.FieldSpuDetails]
	return ok
}

// ResetSpuDetails resets all changes to the "spu_details" field.
func (m *GoodsSpuMutation) ResetSpuDetails() {
	m.spu_details = nil
	delete(m.clearedFields, goodsspu.FieldSpuDetails)
}

// SetIsCustomSku sets the "is_custom_sku" field.
func (m *GoodsSpuMutation) SetIsCustomSku(b bool) {
	m.is_custom_sku = &b
}

// IsCustomSku returns the value of the "is_custom_sku" field in the mutation.
func (m *GoodsSpuMutation) IsCustomSku() (r bool, exists bool) {
	v := m.is_custom_sku
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCustomSku returns the old "is_custom_sku" field's value of the GoodsSpu entity.
// If the GoodsSpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpuMutation) OldIsCustomSku(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsCustomSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsCustomSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCustomSku: %w", err)
	}
	return oldValue.IsCustomSku, nil
}

// ResetIsCustomSku resets all changes to the "is_custom_sku" field.
func (m *GoodsSpuMutation) ResetIsCustomSku() {
	m.is_custom_sku = nil
}

// SetGoodsClassifyID sets the "goods_classify" edge to the GoodsClassify entity by id.
func (m *GoodsSpuMutation) SetGoodsClassifyID(id int) {
	m.goods_classify = &id
}

// ClearGoodsClassify clears the "goods_classify" edge to the GoodsClassify entity.
func (m *GoodsSpuMutation) ClearGoodsClassify() {
	m.clearedgoods_classify = true
}

// GoodsClassifyCleared reports if the "goods_classify" edge to the GoodsClassify entity was cleared.
func (m *GoodsSpuMutation) GoodsClassifyCleared() bool {
	return m.clearedgoods_classify
}

// GoodsClassifyID returns the "goods_classify" edge ID in the mutation.
func (m *GoodsSpuMutation) GoodsClassifyID() (id int, exists bool) {
	if m.goods_classify != nil {
		return *m.goods_classify, true
	}
	return
}

// GoodsClassifyIDs returns the "goods_classify" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GoodsClassifyID instead. It exists only for internal usage by the builders.
func (m *GoodsSpuMutation) GoodsClassifyIDs() (ids []int) {
	if id := m.goods_classify; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGoodsClassify resets all changes to the "goods_classify" edge.
func (m *GoodsSpuMutation) ResetGoodsClassify() {
	m.goods_classify = nil
	m.clearedgoods_classify = false
}

// AddGoodsSkuIDs adds the "goods_sku" edge to the GoodsSku entity by ids.
func (m *GoodsSpuMutation) AddGoodsSkuIDs(ids ...int) {
	if m.goods_sku == nil {
		m.goods_sku = make(map[int]struct{})
	}
	for i := range ids {
		m.goods_sku[ids[i]] = struct{}{}
	}
}

// ClearGoodsSku clears the "goods_sku" edge to the GoodsSku entity.
func (m *GoodsSpuMutation) ClearGoodsSku() {
	m.clearedgoods_sku = true
}

// GoodsSkuCleared reports if the "goods_sku" edge to the GoodsSku entity was cleared.
func (m *GoodsSpuMutation) GoodsSkuCleared() bool {
	return m.clearedgoods_sku
}

// RemoveGoodsSkuIDs removes the "goods_sku" edge to the GoodsSku entity by IDs.
func (m *GoodsSpuMutation) RemoveGoodsSkuIDs(ids ...int) {
	if m.removedgoods_sku == nil {
		m.removedgoods_sku = make(map[int]struct{})
	}
	for i := range ids {
		m.removedgoods_sku[ids[i]] = struct{}{}
	}
}

// RemovedGoodsSku returns the removed IDs of the "goods_sku" edge to the GoodsSku entity.
func (m *GoodsSpuMutation) RemovedGoodsSkuIDs() (ids []int) {
	for id := range m.removedgoods_sku {
		ids = append(ids, id)
	}
	return
}

// GoodsSkuIDs returns the "goods_sku" edge IDs in the mutation.
func (m *GoodsSpuMutation) GoodsSkuIDs() (ids []int) {
	for id := range m.goods_sku {
		ids = append(ids, id)
	}
	return
}

// ResetGoodsSku resets all changes to the "goods_sku" edge.
func (m *GoodsSpuMutation) ResetGoodsSku() {
	m.goods_sku = nil
	m.clearedgoods_sku = false
	m.removedgoods_sku = nil
}

// AddOrderGoodsSkuIDs adds the "order_goods_sku" edge to the OrderGoodsSku entity by ids.
func (m *GoodsSpuMutation) AddOrderGoodsSkuIDs(ids ...int) {
	if m.order_goods_sku == nil {
		m.order_goods_sku = make(map[int]struct{})
	}
	for i := range ids {
		m.order_goods_sku[ids[i]] = struct{}{}
	}
}

// ClearOrderGoodsSku clears the "order_goods_sku" edge to the OrderGoodsSku entity.
func (m *GoodsSpuMutation) ClearOrderGoodsSku() {
	m.clearedorder_goods_sku = true
}

// OrderGoodsSkuCleared reports if the "order_goods_sku" edge to the OrderGoodsSku entity was cleared.
func (m *GoodsSpuMutation) OrderGoodsSkuCleared() bool {
	return m.clearedorder_goods_sku
}

// RemoveOrderGoodsSkuIDs removes the "order_goods_sku" edge to the OrderGoodsSku entity by IDs.
func (m *GoodsSpuMutation) RemoveOrderGoodsSkuIDs(ids ...int) {
	if m.removedorder_goods_sku == nil {
		m.removedorder_goods_sku = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_goods_sku[ids[i]] = struct{}{}
	}
}

// RemovedOrderGoodsSku returns the removed IDs of the "order_goods_sku" edge to the OrderGoodsSku entity.
func (m *GoodsSpuMutation) RemovedOrderGoodsSkuIDs() (ids []int) {
	for id := range m.removedorder_goods_sku {
		ids = append(ids, id)
	}
	return
}

// OrderGoodsSkuIDs returns the "order_goods_sku" edge IDs in the mutation.
func (m *GoodsSpuMutation) OrderGoodsSkuIDs() (ids []int) {
	for id := range m.order_goods_sku {
		ids = append(ids, id)
	}
	return
}

// ResetOrderGoodsSku resets all changes to the "order_goods_sku" edge.
func (m *GoodsSpuMutation) ResetOrderGoodsSku() {
	m.order_goods_sku = nil
	m.clearedorder_goods_sku = false
	m.removedorder_goods_sku = nil
}

// AddGoodsSpuImgIDs adds the "goods_spu_imgs" edge to the GoodsSpuImgs entity by ids.
func (m *GoodsSpuMutation) AddGoodsSpuImgIDs(ids ...int) {
	if m.goods_spu_imgs == nil {
		m.goods_spu_imgs = make(map[int]struct{})
	}
	for i := range ids {
		m.goods_spu_imgs[ids[i]] = struct{}{}
	}
}

// ClearGoodsSpuImgs clears the "goods_spu_imgs" edge to the GoodsSpuImgs entity.
func (m *GoodsSpuMutation) ClearGoodsSpuImgs() {
	m.clearedgoods_spu_imgs = true
}

// GoodsSpuImgsCleared reports if the "goods_spu_imgs" edge to the GoodsSpuImgs entity was cleared.
func (m *GoodsSpuMutation) GoodsSpuImgsCleared() bool {
	return m.clearedgoods_spu_imgs
}

// RemoveGoodsSpuImgIDs removes the "goods_spu_imgs" edge to the GoodsSpuImgs entity by IDs.
func (m *GoodsSpuMutation) RemoveGoodsSpuImgIDs(ids ...int) {
	if m.removedgoods_spu_imgs == nil {
		m.removedgoods_spu_imgs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedgoods_spu_imgs[ids[i]] = struct{}{}
	}
}

// RemovedGoodsSpuImgs returns the removed IDs of the "goods_spu_imgs" edge to the GoodsSpuImgs entity.
func (m *GoodsSpuMutation) RemovedGoodsSpuImgsIDs() (ids []int) {
	for id := range m.removedgoods_spu_imgs {
		ids = append(ids, id)
	}
	return
}

// GoodsSpuImgsIDs returns the "goods_spu_imgs" edge IDs in the mutation.
func (m *GoodsSpuMutation) GoodsSpuImgsIDs() (ids []int) {
	for id := range m.goods_spu_imgs {
		ids = append(ids, id)
	}
	return
}

// ResetGoodsSpuImgs resets all changes to the "goods_spu_imgs" edge.
func (m *GoodsSpuMutation) ResetGoodsSpuImgs() {
	m.goods_spu_imgs = nil
	m.clearedgoods_spu_imgs = false
	m.removedgoods_spu_imgs = nil
}

// Op returns the operation name.
func (m *GoodsSpuMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodsSpu).
func (m *GoodsSpuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodsSpuMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, goodsspu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodsspu.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodsspu.FieldDeletedAt)
	}
	if m.spu_name != nil {
		fields = append(fields, goodsspu.FieldSpuName)
	}
	if m.spu_code != nil {
		fields = append(fields, goodsspu.FieldSpuCode)
	}
	if m.spu_head_img != nil {
		fields = append(fields, goodsspu.FieldSpuHeadImg)
	}
	if m.sales_num != nil {
		fields = append(fields, goodsspu.FieldSalesNum)
	}
	if m.spu_desc != nil {
		fields = append(fields, goodsspu.FieldSpuDesc)
	}
	if m.spu_details != nil {
		fields = append(fields, goodsspu.FieldSpuDetails)
	}
	if m.is_custom_sku != nil {
		fields = append(fields, goodsspu.FieldIsCustomSku)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodsSpuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodsspu.FieldCreatedAt:
		return m.CreatedAt()
	case goodsspu.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodsspu.FieldDeletedAt:
		return m.DeletedAt()
	case goodsspu.FieldSpuName:
		return m.SpuName()
	case goodsspu.FieldSpuCode:
		return m.SpuCode()
	case goodsspu.FieldSpuHeadImg:
		return m.SpuHeadImg()
	case goodsspu.FieldSalesNum:
		return m.SalesNum()
	case goodsspu.FieldSpuDesc:
		return m.SpuDesc()
	case goodsspu.FieldSpuDetails:
		return m.SpuDetails()
	case goodsspu.FieldIsCustomSku:
		return m.IsCustomSku()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodsSpuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodsspu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodsspu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodsspu.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodsspu.FieldSpuName:
		return m.OldSpuName(ctx)
	case goodsspu.FieldSpuCode:
		return m.OldSpuCode(ctx)
	case goodsspu.FieldSpuHeadImg:
		return m.OldSpuHeadImg(ctx)
	case goodsspu.FieldSalesNum:
		return m.OldSalesNum(ctx)
	case goodsspu.FieldSpuDesc:
		return m.OldSpuDesc(ctx)
	case goodsspu.FieldSpuDetails:
		return m.OldSpuDetails(ctx)
	case goodsspu.FieldIsCustomSku:
		return m.OldIsCustomSku(ctx)
	}
	return nil, fmt.Errorf("unknown GoodsSpu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodsSpuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodsspu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodsspu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodsspu.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodsspu.FieldSpuName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuName(v)
		return nil
	case goodsspu.FieldSpuCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuCode(v)
		return nil
	case goodsspu.FieldSpuHeadImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuHeadImg(v)
		return nil
	case goodsspu.FieldSalesNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesNum(v)
		return nil
	case goodsspu.FieldSpuDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuDesc(v)
		return nil
	case goodsspu.FieldSpuDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuDetails(v)
		return nil
	case goodsspu.FieldIsCustomSku:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCustomSku(v)
		return nil
	}
	return fmt.Errorf("unknown GoodsSpu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodsSpuMutation) AddedFields() []string {
	var fields []string
	if m.addsales_num != nil {
		fields = append(fields, goodsspu.FieldSalesNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodsSpuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodsspu.FieldSalesNum:
		return m.AddedSalesNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodsSpuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodsspu.FieldSalesNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalesNum(v)
		return nil
	}
	return fmt.Errorf("unknown GoodsSpu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodsSpuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodsspu.FieldUpdatedAt) {
		fields = append(fields, goodsspu.FieldUpdatedAt)
	}
	if m.FieldCleared(goodsspu.FieldDeletedAt) {
		fields = append(fields, goodsspu.FieldDeletedAt)
	}
	if m.FieldCleared(goodsspu.FieldSpuHeadImg) {
		fields = append(fields, goodsspu.FieldSpuHeadImg)
	}
	if m.FieldCleared(goodsspu.FieldSalesNum) {
		fields = append(fields, goodsspu.FieldSalesNum)
	}
	if m.FieldCleared(goodsspu.FieldSpuDesc) {
		fields = append(fields, goodsspu.FieldSpuDesc)
	}
	if m.FieldCleared(goodsspu.FieldSpuDetails) {
		fields = append(fields, goodsspu.FieldSpuDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodsSpuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodsSpuMutation) ClearField(name string) error {
	switch name {
	case goodsspu.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case goodsspu.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case goodsspu.FieldSpuHeadImg:
		m.ClearSpuHeadImg()
		return nil
	case goodsspu.FieldSalesNum:
		m.ClearSalesNum()
		return nil
	case goodsspu.FieldSpuDesc:
		m.ClearSpuDesc()
		return nil
	case goodsspu.FieldSpuDetails:
		m.ClearSpuDetails()
		return nil
	}
	return fmt.Errorf("unknown GoodsSpu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodsSpuMutation) ResetField(name string) error {
	switch name {
	case goodsspu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodsspu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodsspu.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodsspu.FieldSpuName:
		m.ResetSpuName()
		return nil
	case goodsspu.FieldSpuCode:
		m.ResetSpuCode()
		return nil
	case goodsspu.FieldSpuHeadImg:
		m.ResetSpuHeadImg()
		return nil
	case goodsspu.FieldSalesNum:
		m.ResetSalesNum()
		return nil
	case goodsspu.FieldSpuDesc:
		m.ResetSpuDesc()
		return nil
	case goodsspu.FieldSpuDetails:
		m.ResetSpuDetails()
		return nil
	case goodsspu.FieldIsCustomSku:
		m.ResetIsCustomSku()
		return nil
	}
	return fmt.Errorf("unknown GoodsSpu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodsSpuMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.goods_classify != nil {
		edges = append(edges, goodsspu.EdgeGoodsClassify)
	}
	if m.goods_sku != nil {
		edges = append(edges, goodsspu.EdgeGoodsSku)
	}
	if m.order_goods_sku != nil {
		edges = append(edges, goodsspu.EdgeOrderGoodsSku)
	}
	if m.goods_spu_imgs != nil {
		edges = append(edges, goodsspu.EdgeGoodsSpuImgs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodsSpuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case goodsspu.EdgeGoodsClassify:
		if id := m.goods_classify; id != nil {
			return []ent.Value{*id}
		}
	case goodsspu.EdgeGoodsSku:
		ids := make([]ent.Value, 0, len(m.goods_sku))
		for id := range m.goods_sku {
			ids = append(ids, id)
		}
		return ids
	case goodsspu.EdgeOrderGoodsSku:
		ids := make([]ent.Value, 0, len(m.order_goods_sku))
		for id := range m.order_goods_sku {
			ids = append(ids, id)
		}
		return ids
	case goodsspu.EdgeGoodsSpuImgs:
		ids := make([]ent.Value, 0, len(m.goods_spu_imgs))
		for id := range m.goods_spu_imgs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodsSpuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedgoods_sku != nil {
		edges = append(edges, goodsspu.EdgeGoodsSku)
	}
	if m.removedorder_goods_sku != nil {
		edges = append(edges, goodsspu.EdgeOrderGoodsSku)
	}
	if m.removedgoods_spu_imgs != nil {
		edges = append(edges, goodsspu.EdgeGoodsSpuImgs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodsSpuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case goodsspu.EdgeGoodsSku:
		ids := make([]ent.Value, 0, len(m.removedgoods_sku))
		for id := range m.removedgoods_sku {
			ids = append(ids, id)
		}
		return ids
	case goodsspu.EdgeOrderGoodsSku:
		ids := make([]ent.Value, 0, len(m.removedorder_goods_sku))
		for id := range m.removedorder_goods_sku {
			ids = append(ids, id)
		}
		return ids
	case goodsspu.EdgeGoodsSpuImgs:
		ids := make([]ent.Value, 0, len(m.removedgoods_spu_imgs))
		for id := range m.removedgoods_spu_imgs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodsSpuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedgoods_classify {
		edges = append(edges, goodsspu.EdgeGoodsClassify)
	}
	if m.clearedgoods_sku {
		edges = append(edges, goodsspu.EdgeGoodsSku)
	}
	if m.clearedorder_goods_sku {
		edges = append(edges, goodsspu.EdgeOrderGoodsSku)
	}
	if m.clearedgoods_spu_imgs {
		edges = append(edges, goodsspu.EdgeGoodsSpuImgs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodsSpuMutation) EdgeCleared(name string) bool {
	switch name {
	case goodsspu.EdgeGoodsClassify:
		return m.clearedgoods_classify
	case goodsspu.EdgeGoodsSku:
		return m.clearedgoods_sku
	case goodsspu.EdgeOrderGoodsSku:
		return m.clearedorder_goods_sku
	case goodsspu.EdgeGoodsSpuImgs:
		return m.clearedgoods_spu_imgs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodsSpuMutation) ClearEdge(name string) error {
	switch name {
	case goodsspu.EdgeGoodsClassify:
		m.ClearGoodsClassify()
		return nil
	}
	return fmt.Errorf("unknown GoodsSpu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodsSpuMutation) ResetEdge(name string) error {
	switch name {
	case goodsspu.EdgeGoodsClassify:
		m.ResetGoodsClassify()
		return nil
	case goodsspu.EdgeGoodsSku:
		m.ResetGoodsSku()
		return nil
	case goodsspu.EdgeOrderGoodsSku:
		m.ResetOrderGoodsSku()
		return nil
	case goodsspu.EdgeGoodsSpuImgs:
		m.ResetGoodsSpuImgs()
		return nil
	}
	return fmt.Errorf("unknown GoodsSpu edge %s", name)
}

// GoodsSpuImgsMutation represents an operation that mutates the GoodsSpuImgs nodes in the graph.
type GoodsSpuImgsMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	img_name         *string
	img_path         *string
	clearedFields    map[string]struct{}
	goods_spu        *int
	clearedgoods_spu bool
	done             bool
	oldValue         func(context.Context) (*GoodsSpuImgs, error)
	predicates       []predicate.GoodsSpuImgs
}

var _ ent.Mutation = (*GoodsSpuImgsMutation)(nil)

// goodsspuimgsOption allows management of the mutation configuration using functional options.
type goodsspuimgsOption func(*GoodsSpuImgsMutation)

// newGoodsSpuImgsMutation creates new mutation for the GoodsSpuImgs entity.
func newGoodsSpuImgsMutation(c config, op Op, opts ...goodsspuimgsOption) *GoodsSpuImgsMutation {
	m := &GoodsSpuImgsMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodsSpuImgs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodsSpuImgsID sets the ID field of the mutation.
func withGoodsSpuImgsID(id int) goodsspuimgsOption {
	return func(m *GoodsSpuImgsMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodsSpuImgs
		)
		m.oldValue = func(ctx context.Context) (*GoodsSpuImgs, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodsSpuImgs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodsSpuImgs sets the old GoodsSpuImgs of the mutation.
func withGoodsSpuImgs(node *GoodsSpuImgs) goodsspuimgsOption {
	return func(m *GoodsSpuImgsMutation) {
		m.oldValue = func(context.Context) (*GoodsSpuImgs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodsSpuImgsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodsSpuImgsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *GoodsSpuImgsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodsSpuImgsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodsSpuImgsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodsSpuImgs entity.
// If the GoodsSpuImgs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpuImgsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodsSpuImgsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodsSpuImgsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodsSpuImgsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodsSpuImgs entity.
// If the GoodsSpuImgs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpuImgsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *GoodsSpuImgsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[goodsspuimgs.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *GoodsSpuImgsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[goodsspuimgs.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodsSpuImgsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, goodsspuimgs.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodsSpuImgsMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodsSpuImgsMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodsSpuImgs entity.
// If the GoodsSpuImgs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpuImgsMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GoodsSpuImgsMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[goodsspuimgs.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GoodsSpuImgsMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[goodsspuimgs.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodsSpuImgsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, goodsspuimgs.FieldDeletedAt)
}

// SetImgName sets the "img_name" field.
func (m *GoodsSpuImgsMutation) SetImgName(s string) {
	m.img_name = &s
}

// ImgName returns the value of the "img_name" field in the mutation.
func (m *GoodsSpuImgsMutation) ImgName() (r string, exists bool) {
	v := m.img_name
	if v == nil {
		return
	}
	return *v, true
}

// OldImgName returns the old "img_name" field's value of the GoodsSpuImgs entity.
// If the GoodsSpuImgs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpuImgsMutation) OldImgName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImgName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImgName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImgName: %w", err)
	}
	return oldValue.ImgName, nil
}

// ClearImgName clears the value of the "img_name" field.
func (m *GoodsSpuImgsMutation) ClearImgName() {
	m.img_name = nil
	m.clearedFields[goodsspuimgs.FieldImgName] = struct{}{}
}

// ImgNameCleared returns if the "img_name" field was cleared in this mutation.
func (m *GoodsSpuImgsMutation) ImgNameCleared() bool {
	_, ok := m.clearedFields[goodsspuimgs.FieldImgName]
	return ok
}

// ResetImgName resets all changes to the "img_name" field.
func (m *GoodsSpuImgsMutation) ResetImgName() {
	m.img_name = nil
	delete(m.clearedFields, goodsspuimgs.FieldImgName)
}

// SetImgPath sets the "img_path" field.
func (m *GoodsSpuImgsMutation) SetImgPath(s string) {
	m.img_path = &s
}

// ImgPath returns the value of the "img_path" field in the mutation.
func (m *GoodsSpuImgsMutation) ImgPath() (r string, exists bool) {
	v := m.img_path
	if v == nil {
		return
	}
	return *v, true
}

// OldImgPath returns the old "img_path" field's value of the GoodsSpuImgs entity.
// If the GoodsSpuImgs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodsSpuImgsMutation) OldImgPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImgPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImgPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImgPath: %w", err)
	}
	return oldValue.ImgPath, nil
}

// ClearImgPath clears the value of the "img_path" field.
func (m *GoodsSpuImgsMutation) ClearImgPath() {
	m.img_path = nil
	m.clearedFields[goodsspuimgs.FieldImgPath] = struct{}{}
}

// ImgPathCleared returns if the "img_path" field was cleared in this mutation.
func (m *GoodsSpuImgsMutation) ImgPathCleared() bool {
	_, ok := m.clearedFields[goodsspuimgs.FieldImgPath]
	return ok
}

// ResetImgPath resets all changes to the "img_path" field.
func (m *GoodsSpuImgsMutation) ResetImgPath() {
	m.img_path = nil
	delete(m.clearedFields, goodsspuimgs.FieldImgPath)
}

// SetGoodsSpuID sets the "goods_spu" edge to the GoodsSpu entity by id.
func (m *GoodsSpuImgsMutation) SetGoodsSpuID(id int) {
	m.goods_spu = &id
}

// ClearGoodsSpu clears the "goods_spu" edge to the GoodsSpu entity.
func (m *GoodsSpuImgsMutation) ClearGoodsSpu() {
	m.clearedgoods_spu = true
}

// GoodsSpuCleared reports if the "goods_spu" edge to the GoodsSpu entity was cleared.
func (m *GoodsSpuImgsMutation) GoodsSpuCleared() bool {
	return m.clearedgoods_spu
}

// GoodsSpuID returns the "goods_spu" edge ID in the mutation.
func (m *GoodsSpuImgsMutation) GoodsSpuID() (id int, exists bool) {
	if m.goods_spu != nil {
		return *m.goods_spu, true
	}
	return
}

// GoodsSpuIDs returns the "goods_spu" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GoodsSpuID instead. It exists only for internal usage by the builders.
func (m *GoodsSpuImgsMutation) GoodsSpuIDs() (ids []int) {
	if id := m.goods_spu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGoodsSpu resets all changes to the "goods_spu" edge.
func (m *GoodsSpuImgsMutation) ResetGoodsSpu() {
	m.goods_spu = nil
	m.clearedgoods_spu = false
}

// Op returns the operation name.
func (m *GoodsSpuImgsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodsSpuImgs).
func (m *GoodsSpuImgsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodsSpuImgsMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, goodsspuimgs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodsspuimgs.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodsspuimgs.FieldDeletedAt)
	}
	if m.img_name != nil {
		fields = append(fields, goodsspuimgs.FieldImgName)
	}
	if m.img_path != nil {
		fields = append(fields, goodsspuimgs.FieldImgPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodsSpuImgsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodsspuimgs.FieldCreatedAt:
		return m.CreatedAt()
	case goodsspuimgs.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodsspuimgs.FieldDeletedAt:
		return m.DeletedAt()
	case goodsspuimgs.FieldImgName:
		return m.ImgName()
	case goodsspuimgs.FieldImgPath:
		return m.ImgPath()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodsSpuImgsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodsspuimgs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodsspuimgs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodsspuimgs.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodsspuimgs.FieldImgName:
		return m.OldImgName(ctx)
	case goodsspuimgs.FieldImgPath:
		return m.OldImgPath(ctx)
	}
	return nil, fmt.Errorf("unknown GoodsSpuImgs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodsSpuImgsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodsspuimgs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodsspuimgs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodsspuimgs.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodsspuimgs.FieldImgName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImgName(v)
		return nil
	case goodsspuimgs.FieldImgPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImgPath(v)
		return nil
	}
	return fmt.Errorf("unknown GoodsSpuImgs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodsSpuImgsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodsSpuImgsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodsSpuImgsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GoodsSpuImgs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodsSpuImgsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodsspuimgs.FieldUpdatedAt) {
		fields = append(fields, goodsspuimgs.FieldUpdatedAt)
	}
	if m.FieldCleared(goodsspuimgs.FieldDeletedAt) {
		fields = append(fields, goodsspuimgs.FieldDeletedAt)
	}
	if m.FieldCleared(goodsspuimgs.FieldImgName) {
		fields = append(fields, goodsspuimgs.FieldImgName)
	}
	if m.FieldCleared(goodsspuimgs.FieldImgPath) {
		fields = append(fields, goodsspuimgs.FieldImgPath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodsSpuImgsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodsSpuImgsMutation) ClearField(name string) error {
	switch name {
	case goodsspuimgs.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case goodsspuimgs.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case goodsspuimgs.FieldImgName:
		m.ClearImgName()
		return nil
	case goodsspuimgs.FieldImgPath:
		m.ClearImgPath()
		return nil
	}
	return fmt.Errorf("unknown GoodsSpuImgs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodsSpuImgsMutation) ResetField(name string) error {
	switch name {
	case goodsspuimgs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodsspuimgs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodsspuimgs.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodsspuimgs.FieldImgName:
		m.ResetImgName()
		return nil
	case goodsspuimgs.FieldImgPath:
		m.ResetImgPath()
		return nil
	}
	return fmt.Errorf("unknown GoodsSpuImgs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodsSpuImgsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.goods_spu != nil {
		edges = append(edges, goodsspuimgs.EdgeGoodsSpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodsSpuImgsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case goodsspuimgs.EdgeGoodsSpu:
		if id := m.goods_spu; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodsSpuImgsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodsSpuImgsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodsSpuImgsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgoods_spu {
		edges = append(edges, goodsspuimgs.EdgeGoodsSpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodsSpuImgsMutation) EdgeCleared(name string) bool {
	switch name {
	case goodsspuimgs.EdgeGoodsSpu:
		return m.clearedgoods_spu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodsSpuImgsMutation) ClearEdge(name string) error {
	switch name {
	case goodsspuimgs.EdgeGoodsSpu:
		m.ClearGoodsSpu()
		return nil
	}
	return fmt.Errorf("unknown GoodsSpuImgs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodsSpuImgsMutation) ResetEdge(name string) error {
	switch name {
	case goodsspuimgs.EdgeGoodsSpu:
		m.ResetGoodsSpu()
		return nil
	}
	return fmt.Errorf("unknown GoodsSpuImgs edge %s", name)
}

// OrderAddressMutation represents an operation that mutates the OrderAddress nodes in the graph.
type OrderAddressMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	phone             *string
	province          *string
	city              *string
	area              *string
	detailed          *string
	remark            *string
	clearedFields     map[string]struct{}
	order_info        *int
	clearedorder_info bool
	done              bool
	oldValue          func(context.Context) (*OrderAddress, error)
	predicates        []predicate.OrderAddress
}

var _ ent.Mutation = (*OrderAddressMutation)(nil)

// orderaddressOption allows management of the mutation configuration using functional options.
type orderaddressOption func(*OrderAddressMutation)

// newOrderAddressMutation creates new mutation for the OrderAddress entity.
func newOrderAddressMutation(c config, op Op, opts ...orderaddressOption) *OrderAddressMutation {
	m := &OrderAddressMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderAddressID sets the ID field of the mutation.
func withOrderAddressID(id int) orderaddressOption {
	return func(m *OrderAddressMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderAddress
		)
		m.oldValue = func(ctx context.Context) (*OrderAddress, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderAddress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderAddress sets the old OrderAddress of the mutation.
func withOrderAddress(node *OrderAddress) orderaddressOption {
	return func(m *OrderAddressMutation) {
		m.oldValue = func(context.Context) (*OrderAddress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderAddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderAddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *OrderAddressMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *OrderAddressMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrderAddressMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrderAddress entity.
// If the OrderAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAddressMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrderAddressMutation) ResetName() {
	m.name = nil
}

// SetPhone sets the "phone" field.
func (m *OrderAddressMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *OrderAddressMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the OrderAddress entity.
// If the OrderAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAddressMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *OrderAddressMutation) ResetPhone() {
	m.phone = nil
}

// SetProvince sets the "province" field.
func (m *OrderAddressMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *OrderAddressMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the OrderAddress entity.
// If the OrderAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAddressMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ResetProvince resets all changes to the "province" field.
func (m *OrderAddressMutation) ResetProvince() {
	m.province = nil
}

// SetCity sets the "city" field.
func (m *OrderAddressMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *OrderAddressMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the OrderAddress entity.
// If the OrderAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAddressMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *OrderAddressMutation) ResetCity() {
	m.city = nil
}

// SetArea sets the "area" field.
func (m *OrderAddressMutation) SetArea(s string) {
	m.area = &s
}

// Area returns the value of the "area" field in the mutation.
func (m *OrderAddressMutation) Area() (r string, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldArea returns the old "area" field's value of the OrderAddress entity.
// If the OrderAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAddressMutation) OldArea(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArea: %w", err)
	}
	return oldValue.Area, nil
}

// ResetArea resets all changes to the "area" field.
func (m *OrderAddressMutation) ResetArea() {
	m.area = nil
}

// SetDetailed sets the "detailed" field.
func (m *OrderAddressMutation) SetDetailed(s string) {
	m.detailed = &s
}

// Detailed returns the value of the "detailed" field in the mutation.
func (m *OrderAddressMutation) Detailed() (r string, exists bool) {
	v := m.detailed
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailed returns the old "detailed" field's value of the OrderAddress entity.
// If the OrderAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAddressMutation) OldDetailed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDetailed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDetailed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailed: %w", err)
	}
	return oldValue.Detailed, nil
}

// ResetDetailed resets all changes to the "detailed" field.
func (m *OrderAddressMutation) ResetDetailed() {
	m.detailed = nil
}

// SetRemark sets the "remark" field.
func (m *OrderAddressMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OrderAddressMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the OrderAddress entity.
// If the OrderAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAddressMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *OrderAddressMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[orderaddress.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *OrderAddressMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[orderaddress.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *OrderAddressMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, orderaddress.FieldRemark)
}

// SetOrderInfoID sets the "order_info" edge to the OrderInfo entity by id.
func (m *OrderAddressMutation) SetOrderInfoID(id int) {
	m.order_info = &id
}

// ClearOrderInfo clears the "order_info" edge to the OrderInfo entity.
func (m *OrderAddressMutation) ClearOrderInfo() {
	m.clearedorder_info = true
}

// OrderInfoCleared reports if the "order_info" edge to the OrderInfo entity was cleared.
func (m *OrderAddressMutation) OrderInfoCleared() bool {
	return m.clearedorder_info
}

// OrderInfoID returns the "order_info" edge ID in the mutation.
func (m *OrderAddressMutation) OrderInfoID() (id int, exists bool) {
	if m.order_info != nil {
		return *m.order_info, true
	}
	return
}

// OrderInfoIDs returns the "order_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderInfoID instead. It exists only for internal usage by the builders.
func (m *OrderAddressMutation) OrderInfoIDs() (ids []int) {
	if id := m.order_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderInfo resets all changes to the "order_info" edge.
func (m *OrderAddressMutation) ResetOrderInfo() {
	m.order_info = nil
	m.clearedorder_info = false
}

// Op returns the operation name.
func (m *OrderAddressMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderAddress).
func (m *OrderAddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderAddressMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, orderaddress.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, orderaddress.FieldPhone)
	}
	if m.province != nil {
		fields = append(fields, orderaddress.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, orderaddress.FieldCity)
	}
	if m.area != nil {
		fields = append(fields, orderaddress.FieldArea)
	}
	if m.detailed != nil {
		fields = append(fields, orderaddress.FieldDetailed)
	}
	if m.remark != nil {
		fields = append(fields, orderaddress.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderAddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderaddress.FieldName:
		return m.Name()
	case orderaddress.FieldPhone:
		return m.Phone()
	case orderaddress.FieldProvince:
		return m.Province()
	case orderaddress.FieldCity:
		return m.City()
	case orderaddress.FieldArea:
		return m.Area()
	case orderaddress.FieldDetailed:
		return m.Detailed()
	case orderaddress.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderAddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderaddress.FieldName:
		return m.OldName(ctx)
	case orderaddress.FieldPhone:
		return m.OldPhone(ctx)
	case orderaddress.FieldProvince:
		return m.OldProvince(ctx)
	case orderaddress.FieldCity:
		return m.OldCity(ctx)
	case orderaddress.FieldArea:
		return m.OldArea(ctx)
	case orderaddress.FieldDetailed:
		return m.OldDetailed(ctx)
	case orderaddress.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown OrderAddress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderaddress.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case orderaddress.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case orderaddress.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case orderaddress.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case orderaddress.FieldArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArea(v)
		return nil
	case orderaddress.FieldDetailed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailed(v)
		return nil
	case orderaddress.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown OrderAddress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderAddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderAddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderAddress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderAddressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderaddress.FieldRemark) {
		fields = append(fields, orderaddress.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderAddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderAddressMutation) ClearField(name string) error {
	switch name {
	case orderaddress.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown OrderAddress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderAddressMutation) ResetField(name string) error {
	switch name {
	case orderaddress.FieldName:
		m.ResetName()
		return nil
	case orderaddress.FieldPhone:
		m.ResetPhone()
		return nil
	case orderaddress.FieldProvince:
		m.ResetProvince()
		return nil
	case orderaddress.FieldCity:
		m.ResetCity()
		return nil
	case orderaddress.FieldArea:
		m.ResetArea()
		return nil
	case orderaddress.FieldDetailed:
		m.ResetDetailed()
		return nil
	case orderaddress.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown OrderAddress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderAddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.order_info != nil {
		edges = append(edges, orderaddress.EdgeOrderInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderAddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderaddress.EdgeOrderInfo:
		if id := m.order_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderAddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderAddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderAddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorder_info {
		edges = append(edges, orderaddress.EdgeOrderInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderAddressMutation) EdgeCleared(name string) bool {
	switch name {
	case orderaddress.EdgeOrderInfo:
		return m.clearedorder_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderAddressMutation) ClearEdge(name string) error {
	switch name {
	case orderaddress.EdgeOrderInfo:
		m.ClearOrderInfo()
		return nil
	}
	return fmt.Errorf("unknown OrderAddress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderAddressMutation) ResetEdge(name string) error {
	switch name {
	case orderaddress.EdgeOrderInfo:
		m.ResetOrderInfo()
		return nil
	}
	return fmt.Errorf("unknown OrderAddress edge %s", name)
}

// OrderGoodsSkuMutation represents an operation that mutates the OrderGoodsSku nodes in the graph.
type OrderGoodsSkuMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	spu_name          *string
	spu_code          *string
	spu_head_img      *string
	spu_desc          *string
	spu_details       *string
	is_custom_sku     *bool
	specs_option      *[]*schema.SpecsOptionType
	sku_id            *int
	addsku_id         *int
	sku_name          *string
	sku_code          *string
	price             *int
	addprice          *int
	amount            *int
	addamount         *int
	clearedFields     map[string]struct{}
	goods_spu         *int
	clearedgoods_spu  bool
	order_info        *int
	clearedorder_info bool
	done              bool
	oldValue          func(context.Context) (*OrderGoodsSku, error)
	predicates        []predicate.OrderGoodsSku
}

var _ ent.Mutation = (*OrderGoodsSkuMutation)(nil)

// ordergoodsskuOption allows management of the mutation configuration using functional options.
type ordergoodsskuOption func(*OrderGoodsSkuMutation)

// newOrderGoodsSkuMutation creates new mutation for the OrderGoodsSku entity.
func newOrderGoodsSkuMutation(c config, op Op, opts ...ordergoodsskuOption) *OrderGoodsSkuMutation {
	m := &OrderGoodsSkuMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderGoodsSku,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderGoodsSkuID sets the ID field of the mutation.
func withOrderGoodsSkuID(id int) ordergoodsskuOption {
	return func(m *OrderGoodsSkuMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderGoodsSku
		)
		m.oldValue = func(ctx context.Context) (*OrderGoodsSku, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderGoodsSku.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderGoodsSku sets the old OrderGoodsSku of the mutation.
func withOrderGoodsSku(node *OrderGoodsSku) ordergoodsskuOption {
	return func(m *OrderGoodsSkuMutation) {
		m.oldValue = func(context.Context) (*OrderGoodsSku, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderGoodsSkuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderGoodsSkuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *OrderGoodsSkuMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderGoodsSkuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderGoodsSkuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderGoodsSku entity.
// If the OrderGoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderGoodsSkuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderGoodsSkuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderGoodsSkuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderGoodsSkuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderGoodsSku entity.
// If the OrderGoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderGoodsSkuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderGoodsSkuMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[ordergoodssku.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderGoodsSkuMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[ordergoodssku.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderGoodsSkuMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, ordergoodssku.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderGoodsSkuMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderGoodsSkuMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderGoodsSku entity.
// If the OrderGoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderGoodsSkuMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrderGoodsSkuMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[ordergoodssku.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrderGoodsSkuMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[ordergoodssku.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderGoodsSkuMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, ordergoodssku.FieldDeletedAt)
}

// SetSpuName sets the "spu_name" field.
func (m *OrderGoodsSkuMutation) SetSpuName(s string) {
	m.spu_name = &s
}

// SpuName returns the value of the "spu_name" field in the mutation.
func (m *OrderGoodsSkuMutation) SpuName() (r string, exists bool) {
	v := m.spu_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuName returns the old "spu_name" field's value of the OrderGoodsSku entity.
// If the OrderGoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderGoodsSkuMutation) OldSpuName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuName: %w", err)
	}
	return oldValue.SpuName, nil
}

// ResetSpuName resets all changes to the "spu_name" field.
func (m *OrderGoodsSkuMutation) ResetSpuName() {
	m.spu_name = nil
}

// SetSpuCode sets the "spu_code" field.
func (m *OrderGoodsSkuMutation) SetSpuCode(s string) {
	m.spu_code = &s
}

// SpuCode returns the value of the "spu_code" field in the mutation.
func (m *OrderGoodsSkuMutation) SpuCode() (r string, exists bool) {
	v := m.spu_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuCode returns the old "spu_code" field's value of the OrderGoodsSku entity.
// If the OrderGoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderGoodsSkuMutation) OldSpuCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuCode: %w", err)
	}
	return oldValue.SpuCode, nil
}

// ResetSpuCode resets all changes to the "spu_code" field.
func (m *OrderGoodsSkuMutation) ResetSpuCode() {
	m.spu_code = nil
}

// SetSpuHeadImg sets the "spu_head_img" field.
func (m *OrderGoodsSkuMutation) SetSpuHeadImg(s string) {
	m.spu_head_img = &s
}

// SpuHeadImg returns the value of the "spu_head_img" field in the mutation.
func (m *OrderGoodsSkuMutation) SpuHeadImg() (r string, exists bool) {
	v := m.spu_head_img
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuHeadImg returns the old "spu_head_img" field's value of the OrderGoodsSku entity.
// If the OrderGoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderGoodsSkuMutation) OldSpuHeadImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuHeadImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuHeadImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuHeadImg: %w", err)
	}
	return oldValue.SpuHeadImg, nil
}

// ClearSpuHeadImg clears the value of the "spu_head_img" field.
func (m *OrderGoodsSkuMutation) ClearSpuHeadImg() {
	m.spu_head_img = nil
	m.clearedFields[ordergoodssku.FieldSpuHeadImg] = struct{}{}
}

// SpuHeadImgCleared returns if the "spu_head_img" field was cleared in this mutation.
func (m *OrderGoodsSkuMutation) SpuHeadImgCleared() bool {
	_, ok := m.clearedFields[ordergoodssku.FieldSpuHeadImg]
	return ok
}

// ResetSpuHeadImg resets all changes to the "spu_head_img" field.
func (m *OrderGoodsSkuMutation) ResetSpuHeadImg() {
	m.spu_head_img = nil
	delete(m.clearedFields, ordergoodssku.FieldSpuHeadImg)
}

// SetSpuDesc sets the "spu_desc" field.
func (m *OrderGoodsSkuMutation) SetSpuDesc(s string) {
	m.spu_desc = &s
}

// SpuDesc returns the value of the "spu_desc" field in the mutation.
func (m *OrderGoodsSkuMutation) SpuDesc() (r string, exists bool) {
	v := m.spu_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuDesc returns the old "spu_desc" field's value of the OrderGoodsSku entity.
// If the OrderGoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderGoodsSkuMutation) OldSpuDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuDesc: %w", err)
	}
	return oldValue.SpuDesc, nil
}

// ClearSpuDesc clears the value of the "spu_desc" field.
func (m *OrderGoodsSkuMutation) ClearSpuDesc() {
	m.spu_desc = nil
	m.clearedFields[ordergoodssku.FieldSpuDesc] = struct{}{}
}

// SpuDescCleared returns if the "spu_desc" field was cleared in this mutation.
func (m *OrderGoodsSkuMutation) SpuDescCleared() bool {
	_, ok := m.clearedFields[ordergoodssku.FieldSpuDesc]
	return ok
}

// ResetSpuDesc resets all changes to the "spu_desc" field.
func (m *OrderGoodsSkuMutation) ResetSpuDesc() {
	m.spu_desc = nil
	delete(m.clearedFields, ordergoodssku.FieldSpuDesc)
}

// SetSpuDetails sets the "spu_details" field.
func (m *OrderGoodsSkuMutation) SetSpuDetails(s string) {
	m.spu_details = &s
}

// SpuDetails returns the value of the "spu_details" field in the mutation.
func (m *OrderGoodsSkuMutation) SpuDetails() (r string, exists bool) {
	v := m.spu_details
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuDetails returns the old "spu_details" field's value of the OrderGoodsSku entity.
// If the OrderGoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderGoodsSkuMutation) OldSpuDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuDetails: %w", err)
	}
	return oldValue.SpuDetails, nil
}

// ClearSpuDetails clears the value of the "spu_details" field.
func (m *OrderGoodsSkuMutation) ClearSpuDetails() {
	m.spu_details = nil
	m.clearedFields[ordergoodssku.FieldSpuDetails] = struct{}{}
}

// SpuDetailsCleared returns if the "spu_details" field was cleared in this mutation.
func (m *OrderGoodsSkuMutation) SpuDetailsCleared() bool {
	_, ok := m.clearedFields[ordergoodssku.FieldSpuDetails]
	return ok
}

// ResetSpuDetails resets all changes to the "spu_details" field.
func (m *OrderGoodsSkuMutation) ResetSpuDetails() {
	m.spu_details = nil
	delete(m.clearedFields, ordergoodssku.FieldSpuDetails)
}

// SetIsCustomSku sets the "is_custom_sku" field.
func (m *OrderGoodsSkuMutation) SetIsCustomSku(b bool) {
	m.is_custom_sku = &b
}

// IsCustomSku returns the value of the "is_custom_sku" field in the mutation.
func (m *OrderGoodsSkuMutation) IsCustomSku() (r bool, exists bool) {
	v := m.is_custom_sku
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCustomSku returns the old "is_custom_sku" field's value of the OrderGoodsSku entity.
// If the OrderGoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderGoodsSkuMutation) OldIsCustomSku(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsCustomSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsCustomSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCustomSku: %w", err)
	}
	return oldValue.IsCustomSku, nil
}

// ResetIsCustomSku resets all changes to the "is_custom_sku" field.
func (m *OrderGoodsSkuMutation) ResetIsCustomSku() {
	m.is_custom_sku = nil
}

// SetSpecsOption sets the "specs_option" field.
func (m *OrderGoodsSkuMutation) SetSpecsOption(sot []*schema.SpecsOptionType) {
	m.specs_option = &sot
}

// SpecsOption returns the value of the "specs_option" field in the mutation.
func (m *OrderGoodsSkuMutation) SpecsOption() (r []*schema.SpecsOptionType, exists bool) {
	v := m.specs_option
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecsOption returns the old "specs_option" field's value of the OrderGoodsSku entity.
// If the OrderGoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderGoodsSkuMutation) OldSpecsOption(ctx context.Context) (v []*schema.SpecsOptionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecsOption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecsOption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecsOption: %w", err)
	}
	return oldValue.SpecsOption, nil
}

// ResetSpecsOption resets all changes to the "specs_option" field.
func (m *OrderGoodsSkuMutation) ResetSpecsOption() {
	m.specs_option = nil
}

// SetSkuID sets the "sku_id" field.
func (m *OrderGoodsSkuMutation) SetSkuID(i int) {
	m.sku_id = &i
	m.addsku_id = nil
}

// SkuID returns the value of the "sku_id" field in the mutation.
func (m *OrderGoodsSkuMutation) SkuID() (r int, exists bool) {
	v := m.sku_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSkuID returns the old "sku_id" field's value of the OrderGoodsSku entity.
// If the OrderGoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderGoodsSkuMutation) OldSkuID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSkuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSkuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkuID: %w", err)
	}
	return oldValue.SkuID, nil
}

// AddSkuID adds i to the "sku_id" field.
func (m *OrderGoodsSkuMutation) AddSkuID(i int) {
	if m.addsku_id != nil {
		*m.addsku_id += i
	} else {
		m.addsku_id = &i
	}
}

// AddedSkuID returns the value that was added to the "sku_id" field in this mutation.
func (m *OrderGoodsSkuMutation) AddedSkuID() (r int, exists bool) {
	v := m.addsku_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSkuID resets all changes to the "sku_id" field.
func (m *OrderGoodsSkuMutation) ResetSkuID() {
	m.sku_id = nil
	m.addsku_id = nil
}

// SetSkuName sets the "sku_name" field.
func (m *OrderGoodsSkuMutation) SetSkuName(s string) {
	m.sku_name = &s
}

// SkuName returns the value of the "sku_name" field in the mutation.
func (m *OrderGoodsSkuMutation) SkuName() (r string, exists bool) {
	v := m.sku_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSkuName returns the old "sku_name" field's value of the OrderGoodsSku entity.
// If the OrderGoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderGoodsSkuMutation) OldSkuName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSkuName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSkuName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkuName: %w", err)
	}
	return oldValue.SkuName, nil
}

// ResetSkuName resets all changes to the "sku_name" field.
func (m *OrderGoodsSkuMutation) ResetSkuName() {
	m.sku_name = nil
}

// SetSkuCode sets the "sku_code" field.
func (m *OrderGoodsSkuMutation) SetSkuCode(s string) {
	m.sku_code = &s
}

// SkuCode returns the value of the "sku_code" field in the mutation.
func (m *OrderGoodsSkuMutation) SkuCode() (r string, exists bool) {
	v := m.sku_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSkuCode returns the old "sku_code" field's value of the OrderGoodsSku entity.
// If the OrderGoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderGoodsSkuMutation) OldSkuCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSkuCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSkuCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkuCode: %w", err)
	}
	return oldValue.SkuCode, nil
}

// ResetSkuCode resets all changes to the "sku_code" field.
func (m *OrderGoodsSkuMutation) ResetSkuCode() {
	m.sku_code = nil
}

// SetPrice sets the "price" field.
func (m *OrderGoodsSkuMutation) SetPrice(i int) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *OrderGoodsSkuMutation) Price() (r int, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the OrderGoodsSku entity.
// If the OrderGoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderGoodsSkuMutation) OldPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *OrderGoodsSkuMutation) AddPrice(i int) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *OrderGoodsSkuMutation) AddedPrice() (r int, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *OrderGoodsSkuMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetAmount sets the "amount" field.
func (m *OrderGoodsSkuMutation) SetAmount(i int) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *OrderGoodsSkuMutation) Amount() (r int, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the OrderGoodsSku entity.
// If the OrderGoodsSku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderGoodsSkuMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *OrderGoodsSkuMutation) AddAmount(i int) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *OrderGoodsSkuMutation) AddedAmount() (r int, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *OrderGoodsSkuMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetGoodsSpuID sets the "goods_spu" edge to the GoodsSpu entity by id.
func (m *OrderGoodsSkuMutation) SetGoodsSpuID(id int) {
	m.goods_spu = &id
}

// ClearGoodsSpu clears the "goods_spu" edge to the GoodsSpu entity.
func (m *OrderGoodsSkuMutation) ClearGoodsSpu() {
	m.clearedgoods_spu = true
}

// GoodsSpuCleared reports if the "goods_spu" edge to the GoodsSpu entity was cleared.
func (m *OrderGoodsSkuMutation) GoodsSpuCleared() bool {
	return m.clearedgoods_spu
}

// GoodsSpuID returns the "goods_spu" edge ID in the mutation.
func (m *OrderGoodsSkuMutation) GoodsSpuID() (id int, exists bool) {
	if m.goods_spu != nil {
		return *m.goods_spu, true
	}
	return
}

// GoodsSpuIDs returns the "goods_spu" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GoodsSpuID instead. It exists only for internal usage by the builders.
func (m *OrderGoodsSkuMutation) GoodsSpuIDs() (ids []int) {
	if id := m.goods_spu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGoodsSpu resets all changes to the "goods_spu" edge.
func (m *OrderGoodsSkuMutation) ResetGoodsSpu() {
	m.goods_spu = nil
	m.clearedgoods_spu = false
}

// SetOrderInfoID sets the "order_info" edge to the OrderInfo entity by id.
func (m *OrderGoodsSkuMutation) SetOrderInfoID(id int) {
	m.order_info = &id
}

// ClearOrderInfo clears the "order_info" edge to the OrderInfo entity.
func (m *OrderGoodsSkuMutation) ClearOrderInfo() {
	m.clearedorder_info = true
}

// OrderInfoCleared reports if the "order_info" edge to the OrderInfo entity was cleared.
func (m *OrderGoodsSkuMutation) OrderInfoCleared() bool {
	return m.clearedorder_info
}

// OrderInfoID returns the "order_info" edge ID in the mutation.
func (m *OrderGoodsSkuMutation) OrderInfoID() (id int, exists bool) {
	if m.order_info != nil {
		return *m.order_info, true
	}
	return
}

// OrderInfoIDs returns the "order_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderInfoID instead. It exists only for internal usage by the builders.
func (m *OrderGoodsSkuMutation) OrderInfoIDs() (ids []int) {
	if id := m.order_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderInfo resets all changes to the "order_info" edge.
func (m *OrderGoodsSkuMutation) ResetOrderInfo() {
	m.order_info = nil
	m.clearedorder_info = false
}

// Op returns the operation name.
func (m *OrderGoodsSkuMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderGoodsSku).
func (m *OrderGoodsSkuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderGoodsSkuMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, ordergoodssku.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ordergoodssku.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, ordergoodssku.FieldDeletedAt)
	}
	if m.spu_name != nil {
		fields = append(fields, ordergoodssku.FieldSpuName)
	}
	if m.spu_code != nil {
		fields = append(fields, ordergoodssku.FieldSpuCode)
	}
	if m.spu_head_img != nil {
		fields = append(fields, ordergoodssku.FieldSpuHeadImg)
	}
	if m.spu_desc != nil {
		fields = append(fields, ordergoodssku.FieldSpuDesc)
	}
	if m.spu_details != nil {
		fields = append(fields, ordergoodssku.FieldSpuDetails)
	}
	if m.is_custom_sku != nil {
		fields = append(fields, ordergoodssku.FieldIsCustomSku)
	}
	if m.specs_option != nil {
		fields = append(fields, ordergoodssku.FieldSpecsOption)
	}
	if m.sku_id != nil {
		fields = append(fields, ordergoodssku.FieldSkuID)
	}
	if m.sku_name != nil {
		fields = append(fields, ordergoodssku.FieldSkuName)
	}
	if m.sku_code != nil {
		fields = append(fields, ordergoodssku.FieldSkuCode)
	}
	if m.price != nil {
		fields = append(fields, ordergoodssku.FieldPrice)
	}
	if m.amount != nil {
		fields = append(fields, ordergoodssku.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderGoodsSkuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ordergoodssku.FieldCreatedAt:
		return m.CreatedAt()
	case ordergoodssku.FieldUpdatedAt:
		return m.UpdatedAt()
	case ordergoodssku.FieldDeletedAt:
		return m.DeletedAt()
	case ordergoodssku.FieldSpuName:
		return m.SpuName()
	case ordergoodssku.FieldSpuCode:
		return m.SpuCode()
	case ordergoodssku.FieldSpuHeadImg:
		return m.SpuHeadImg()
	case ordergoodssku.FieldSpuDesc:
		return m.SpuDesc()
	case ordergoodssku.FieldSpuDetails:
		return m.SpuDetails()
	case ordergoodssku.FieldIsCustomSku:
		return m.IsCustomSku()
	case ordergoodssku.FieldSpecsOption:
		return m.SpecsOption()
	case ordergoodssku.FieldSkuID:
		return m.SkuID()
	case ordergoodssku.FieldSkuName:
		return m.SkuName()
	case ordergoodssku.FieldSkuCode:
		return m.SkuCode()
	case ordergoodssku.FieldPrice:
		return m.Price()
	case ordergoodssku.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderGoodsSkuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ordergoodssku.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ordergoodssku.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ordergoodssku.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case ordergoodssku.FieldSpuName:
		return m.OldSpuName(ctx)
	case ordergoodssku.FieldSpuCode:
		return m.OldSpuCode(ctx)
	case ordergoodssku.FieldSpuHeadImg:
		return m.OldSpuHeadImg(ctx)
	case ordergoodssku.FieldSpuDesc:
		return m.OldSpuDesc(ctx)
	case ordergoodssku.FieldSpuDetails:
		return m.OldSpuDetails(ctx)
	case ordergoodssku.FieldIsCustomSku:
		return m.OldIsCustomSku(ctx)
	case ordergoodssku.FieldSpecsOption:
		return m.OldSpecsOption(ctx)
	case ordergoodssku.FieldSkuID:
		return m.OldSkuID(ctx)
	case ordergoodssku.FieldSkuName:
		return m.OldSkuName(ctx)
	case ordergoodssku.FieldSkuCode:
		return m.OldSkuCode(ctx)
	case ordergoodssku.FieldPrice:
		return m.OldPrice(ctx)
	case ordergoodssku.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown OrderGoodsSku field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderGoodsSkuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ordergoodssku.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ordergoodssku.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ordergoodssku.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case ordergoodssku.FieldSpuName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuName(v)
		return nil
	case ordergoodssku.FieldSpuCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuCode(v)
		return nil
	case ordergoodssku.FieldSpuHeadImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuHeadImg(v)
		return nil
	case ordergoodssku.FieldSpuDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuDesc(v)
		return nil
	case ordergoodssku.FieldSpuDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuDetails(v)
		return nil
	case ordergoodssku.FieldIsCustomSku:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCustomSku(v)
		return nil
	case ordergoodssku.FieldSpecsOption:
		v, ok := value.([]*schema.SpecsOptionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecsOption(v)
		return nil
	case ordergoodssku.FieldSkuID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkuID(v)
		return nil
	case ordergoodssku.FieldSkuName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkuName(v)
		return nil
	case ordergoodssku.FieldSkuCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkuCode(v)
		return nil
	case ordergoodssku.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case ordergoodssku.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown OrderGoodsSku field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderGoodsSkuMutation) AddedFields() []string {
	var fields []string
	if m.addsku_id != nil {
		fields = append(fields, ordergoodssku.FieldSkuID)
	}
	if m.addprice != nil {
		fields = append(fields, ordergoodssku.FieldPrice)
	}
	if m.addamount != nil {
		fields = append(fields, ordergoodssku.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderGoodsSkuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ordergoodssku.FieldSkuID:
		return m.AddedSkuID()
	case ordergoodssku.FieldPrice:
		return m.AddedPrice()
	case ordergoodssku.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderGoodsSkuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ordergoodssku.FieldSkuID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSkuID(v)
		return nil
	case ordergoodssku.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case ordergoodssku.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown OrderGoodsSku numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderGoodsSkuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ordergoodssku.FieldUpdatedAt) {
		fields = append(fields, ordergoodssku.FieldUpdatedAt)
	}
	if m.FieldCleared(ordergoodssku.FieldDeletedAt) {
		fields = append(fields, ordergoodssku.FieldDeletedAt)
	}
	if m.FieldCleared(ordergoodssku.FieldSpuHeadImg) {
		fields = append(fields, ordergoodssku.FieldSpuHeadImg)
	}
	if m.FieldCleared(ordergoodssku.FieldSpuDesc) {
		fields = append(fields, ordergoodssku.FieldSpuDesc)
	}
	if m.FieldCleared(ordergoodssku.FieldSpuDetails) {
		fields = append(fields, ordergoodssku.FieldSpuDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderGoodsSkuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderGoodsSkuMutation) ClearField(name string) error {
	switch name {
	case ordergoodssku.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case ordergoodssku.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case ordergoodssku.FieldSpuHeadImg:
		m.ClearSpuHeadImg()
		return nil
	case ordergoodssku.FieldSpuDesc:
		m.ClearSpuDesc()
		return nil
	case ordergoodssku.FieldSpuDetails:
		m.ClearSpuDetails()
		return nil
	}
	return fmt.Errorf("unknown OrderGoodsSku nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderGoodsSkuMutation) ResetField(name string) error {
	switch name {
	case ordergoodssku.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ordergoodssku.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ordergoodssku.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case ordergoodssku.FieldSpuName:
		m.ResetSpuName()
		return nil
	case ordergoodssku.FieldSpuCode:
		m.ResetSpuCode()
		return nil
	case ordergoodssku.FieldSpuHeadImg:
		m.ResetSpuHeadImg()
		return nil
	case ordergoodssku.FieldSpuDesc:
		m.ResetSpuDesc()
		return nil
	case ordergoodssku.FieldSpuDetails:
		m.ResetSpuDetails()
		return nil
	case ordergoodssku.FieldIsCustomSku:
		m.ResetIsCustomSku()
		return nil
	case ordergoodssku.FieldSpecsOption:
		m.ResetSpecsOption()
		return nil
	case ordergoodssku.FieldSkuID:
		m.ResetSkuID()
		return nil
	case ordergoodssku.FieldSkuName:
		m.ResetSkuName()
		return nil
	case ordergoodssku.FieldSkuCode:
		m.ResetSkuCode()
		return nil
	case ordergoodssku.FieldPrice:
		m.ResetPrice()
		return nil
	case ordergoodssku.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown OrderGoodsSku field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderGoodsSkuMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.goods_spu != nil {
		edges = append(edges, ordergoodssku.EdgeGoodsSpu)
	}
	if m.order_info != nil {
		edges = append(edges, ordergoodssku.EdgeOrderInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderGoodsSkuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ordergoodssku.EdgeGoodsSpu:
		if id := m.goods_spu; id != nil {
			return []ent.Value{*id}
		}
	case ordergoodssku.EdgeOrderInfo:
		if id := m.order_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderGoodsSkuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderGoodsSkuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderGoodsSkuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgoods_spu {
		edges = append(edges, ordergoodssku.EdgeGoodsSpu)
	}
	if m.clearedorder_info {
		edges = append(edges, ordergoodssku.EdgeOrderInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderGoodsSkuMutation) EdgeCleared(name string) bool {
	switch name {
	case ordergoodssku.EdgeGoodsSpu:
		return m.clearedgoods_spu
	case ordergoodssku.EdgeOrderInfo:
		return m.clearedorder_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderGoodsSkuMutation) ClearEdge(name string) error {
	switch name {
	case ordergoodssku.EdgeGoodsSpu:
		m.ClearGoodsSpu()
		return nil
	case ordergoodssku.EdgeOrderInfo:
		m.ClearOrderInfo()
		return nil
	}
	return fmt.Errorf("unknown OrderGoodsSku unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderGoodsSkuMutation) ResetEdge(name string) error {
	switch name {
	case ordergoodssku.EdgeGoodsSpu:
		m.ResetGoodsSpu()
		return nil
	case ordergoodssku.EdgeOrderInfo:
		m.ResetOrderInfo()
		return nil
	}
	return fmt.Errorf("unknown OrderGoodsSku edge %s", name)
}

// OrderInfoMutation represents an operation that mutates the OrderInfo nodes in the graph.
type OrderInfoMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	order_number           *string
	pay_method             *int8
	addpay_method          *int8
	pay_money              *int
	addpay_money           *int
	remark                 *string
	status                 *int8
	addstatus              *int8
	delivery_status        *int8
	adddelivery_status     *int8
	clearedFields          map[string]struct{}
	customer               *int
	clearedcustomer        bool
	order_goods_sku        map[int]struct{}
	removedorder_goods_sku map[int]struct{}
	clearedorder_goods_sku bool
	order_address          map[int]struct{}
	removedorder_address   map[int]struct{}
	clearedorder_address   bool
	wechat_pay             map[int]struct{}
	removedwechat_pay      map[int]struct{}
	clearedwechat_pay      bool
	done                   bool
	oldValue               func(context.Context) (*OrderInfo, error)
	predicates             []predicate.OrderInfo
}

var _ ent.Mutation = (*OrderInfoMutation)(nil)

// orderinfoOption allows management of the mutation configuration using functional options.
type orderinfoOption func(*OrderInfoMutation)

// newOrderInfoMutation creates new mutation for the OrderInfo entity.
func newOrderInfoMutation(c config, op Op, opts ...orderinfoOption) *OrderInfoMutation {
	m := &OrderInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderInfoID sets the ID field of the mutation.
func withOrderInfoID(id int) orderinfoOption {
	return func(m *OrderInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderInfo
		)
		m.oldValue = func(ctx context.Context) (*OrderInfo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderInfo sets the old OrderInfo of the mutation.
func withOrderInfo(node *OrderInfo) orderinfoOption {
	return func(m *OrderInfoMutation) {
		m.oldValue = func(context.Context) (*OrderInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *OrderInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrderInfoMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orderinfo.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrderInfoMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orderinfo.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderInfoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderInfoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrderInfoMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[orderinfo.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrderInfoMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, orderinfo.FieldDeletedAt)
}

// SetOrderNumber sets the "order_number" field.
func (m *OrderInfoMutation) SetOrderNumber(s string) {
	m.order_number = &s
}

// OrderNumber returns the value of the "order_number" field in the mutation.
func (m *OrderInfoMutation) OrderNumber() (r string, exists bool) {
	v := m.order_number
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNumber returns the old "order_number" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNumber: %w", err)
	}
	return oldValue.OrderNumber, nil
}

// ResetOrderNumber resets all changes to the "order_number" field.
func (m *OrderInfoMutation) ResetOrderNumber() {
	m.order_number = nil
}

// SetPayMethod sets the "pay_method" field.
func (m *OrderInfoMutation) SetPayMethod(i int8) {
	m.pay_method = &i
	m.addpay_method = nil
}

// PayMethod returns the value of the "pay_method" field in the mutation.
func (m *OrderInfoMutation) PayMethod() (r int8, exists bool) {
	v := m.pay_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPayMethod returns the old "pay_method" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldPayMethod(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayMethod: %w", err)
	}
	return oldValue.PayMethod, nil
}

// AddPayMethod adds i to the "pay_method" field.
func (m *OrderInfoMutation) AddPayMethod(i int8) {
	if m.addpay_method != nil {
		*m.addpay_method += i
	} else {
		m.addpay_method = &i
	}
}

// AddedPayMethod returns the value that was added to the "pay_method" field in this mutation.
func (m *OrderInfoMutation) AddedPayMethod() (r int8, exists bool) {
	v := m.addpay_method
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayMethod clears the value of the "pay_method" field.
func (m *OrderInfoMutation) ClearPayMethod() {
	m.pay_method = nil
	m.addpay_method = nil
	m.clearedFields[orderinfo.FieldPayMethod] = struct{}{}
}

// PayMethodCleared returns if the "pay_method" field was cleared in this mutation.
func (m *OrderInfoMutation) PayMethodCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldPayMethod]
	return ok
}

// ResetPayMethod resets all changes to the "pay_method" field.
func (m *OrderInfoMutation) ResetPayMethod() {
	m.pay_method = nil
	m.addpay_method = nil
	delete(m.clearedFields, orderinfo.FieldPayMethod)
}

// SetPayMoney sets the "pay_money" field.
func (m *OrderInfoMutation) SetPayMoney(i int) {
	m.pay_money = &i
	m.addpay_money = nil
}

// PayMoney returns the value of the "pay_money" field in the mutation.
func (m *OrderInfoMutation) PayMoney() (r int, exists bool) {
	v := m.pay_money
	if v == nil {
		return
	}
	return *v, true
}

// OldPayMoney returns the old "pay_money" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldPayMoney(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayMoney is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayMoney requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayMoney: %w", err)
	}
	return oldValue.PayMoney, nil
}

// AddPayMoney adds i to the "pay_money" field.
func (m *OrderInfoMutation) AddPayMoney(i int) {
	if m.addpay_money != nil {
		*m.addpay_money += i
	} else {
		m.addpay_money = &i
	}
}

// AddedPayMoney returns the value that was added to the "pay_money" field in this mutation.
func (m *OrderInfoMutation) AddedPayMoney() (r int, exists bool) {
	v := m.addpay_money
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayMoney resets all changes to the "pay_money" field.
func (m *OrderInfoMutation) ResetPayMoney() {
	m.pay_money = nil
	m.addpay_money = nil
}

// SetRemark sets the "remark" field.
func (m *OrderInfoMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OrderInfoMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *OrderInfoMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[orderinfo.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *OrderInfoMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *OrderInfoMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, orderinfo.FieldRemark)
}

// SetStatus sets the "status" field.
func (m *OrderInfoMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderInfoMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *OrderInfoMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderInfoMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderInfoMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetDeliveryStatus sets the "delivery_status" field.
func (m *OrderInfoMutation) SetDeliveryStatus(i int8) {
	m.delivery_status = &i
	m.adddelivery_status = nil
}

// DeliveryStatus returns the value of the "delivery_status" field in the mutation.
func (m *OrderInfoMutation) DeliveryStatus() (r int8, exists bool) {
	v := m.delivery_status
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryStatus returns the old "delivery_status" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldDeliveryStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeliveryStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeliveryStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryStatus: %w", err)
	}
	return oldValue.DeliveryStatus, nil
}

// AddDeliveryStatus adds i to the "delivery_status" field.
func (m *OrderInfoMutation) AddDeliveryStatus(i int8) {
	if m.adddelivery_status != nil {
		*m.adddelivery_status += i
	} else {
		m.adddelivery_status = &i
	}
}

// AddedDeliveryStatus returns the value that was added to the "delivery_status" field in this mutation.
func (m *OrderInfoMutation) AddedDeliveryStatus() (r int8, exists bool) {
	v := m.adddelivery_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeliveryStatus resets all changes to the "delivery_status" field.
func (m *OrderInfoMutation) ResetDeliveryStatus() {
	m.delivery_status = nil
	m.adddelivery_status = nil
}

// SetCustomerID sets the "customer" edge to the Customer entity by id.
func (m *OrderInfoMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *OrderInfoMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *OrderInfoMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the "customer" edge ID in the mutation.
func (m *OrderInfoMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *OrderInfoMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *OrderInfoMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// AddOrderGoodsSkuIDs adds the "order_goods_sku" edge to the OrderGoodsSku entity by ids.
func (m *OrderInfoMutation) AddOrderGoodsSkuIDs(ids ...int) {
	if m.order_goods_sku == nil {
		m.order_goods_sku = make(map[int]struct{})
	}
	for i := range ids {
		m.order_goods_sku[ids[i]] = struct{}{}
	}
}

// ClearOrderGoodsSku clears the "order_goods_sku" edge to the OrderGoodsSku entity.
func (m *OrderInfoMutation) ClearOrderGoodsSku() {
	m.clearedorder_goods_sku = true
}

// OrderGoodsSkuCleared reports if the "order_goods_sku" edge to the OrderGoodsSku entity was cleared.
func (m *OrderInfoMutation) OrderGoodsSkuCleared() bool {
	return m.clearedorder_goods_sku
}

// RemoveOrderGoodsSkuIDs removes the "order_goods_sku" edge to the OrderGoodsSku entity by IDs.
func (m *OrderInfoMutation) RemoveOrderGoodsSkuIDs(ids ...int) {
	if m.removedorder_goods_sku == nil {
		m.removedorder_goods_sku = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_goods_sku[ids[i]] = struct{}{}
	}
}

// RemovedOrderGoodsSku returns the removed IDs of the "order_goods_sku" edge to the OrderGoodsSku entity.
func (m *OrderInfoMutation) RemovedOrderGoodsSkuIDs() (ids []int) {
	for id := range m.removedorder_goods_sku {
		ids = append(ids, id)
	}
	return
}

// OrderGoodsSkuIDs returns the "order_goods_sku" edge IDs in the mutation.
func (m *OrderInfoMutation) OrderGoodsSkuIDs() (ids []int) {
	for id := range m.order_goods_sku {
		ids = append(ids, id)
	}
	return
}

// ResetOrderGoodsSku resets all changes to the "order_goods_sku" edge.
func (m *OrderInfoMutation) ResetOrderGoodsSku() {
	m.order_goods_sku = nil
	m.clearedorder_goods_sku = false
	m.removedorder_goods_sku = nil
}

// AddOrderAddresIDs adds the "order_address" edge to the OrderAddress entity by ids.
func (m *OrderInfoMutation) AddOrderAddresIDs(ids ...int) {
	if m.order_address == nil {
		m.order_address = make(map[int]struct{})
	}
	for i := range ids {
		m.order_address[ids[i]] = struct{}{}
	}
}

// ClearOrderAddress clears the "order_address" edge to the OrderAddress entity.
func (m *OrderInfoMutation) ClearOrderAddress() {
	m.clearedorder_address = true
}

// OrderAddressCleared reports if the "order_address" edge to the OrderAddress entity was cleared.
func (m *OrderInfoMutation) OrderAddressCleared() bool {
	return m.clearedorder_address
}

// RemoveOrderAddresIDs removes the "order_address" edge to the OrderAddress entity by IDs.
func (m *OrderInfoMutation) RemoveOrderAddresIDs(ids ...int) {
	if m.removedorder_address == nil {
		m.removedorder_address = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_address[ids[i]] = struct{}{}
	}
}

// RemovedOrderAddress returns the removed IDs of the "order_address" edge to the OrderAddress entity.
func (m *OrderInfoMutation) RemovedOrderAddressIDs() (ids []int) {
	for id := range m.removedorder_address {
		ids = append(ids, id)
	}
	return
}

// OrderAddressIDs returns the "order_address" edge IDs in the mutation.
func (m *OrderInfoMutation) OrderAddressIDs() (ids []int) {
	for id := range m.order_address {
		ids = append(ids, id)
	}
	return
}

// ResetOrderAddress resets all changes to the "order_address" edge.
func (m *OrderInfoMutation) ResetOrderAddress() {
	m.order_address = nil
	m.clearedorder_address = false
	m.removedorder_address = nil
}

// AddWechatPayIDs adds the "wechat_pay" edge to the WeChatPay entity by ids.
func (m *OrderInfoMutation) AddWechatPayIDs(ids ...int) {
	if m.wechat_pay == nil {
		m.wechat_pay = make(map[int]struct{})
	}
	for i := range ids {
		m.wechat_pay[ids[i]] = struct{}{}
	}
}

// ClearWechatPay clears the "wechat_pay" edge to the WeChatPay entity.
func (m *OrderInfoMutation) ClearWechatPay() {
	m.clearedwechat_pay = true
}

// WechatPayCleared reports if the "wechat_pay" edge to the WeChatPay entity was cleared.
func (m *OrderInfoMutation) WechatPayCleared() bool {
	return m.clearedwechat_pay
}

// RemoveWechatPayIDs removes the "wechat_pay" edge to the WeChatPay entity by IDs.
func (m *OrderInfoMutation) RemoveWechatPayIDs(ids ...int) {
	if m.removedwechat_pay == nil {
		m.removedwechat_pay = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwechat_pay[ids[i]] = struct{}{}
	}
}

// RemovedWechatPay returns the removed IDs of the "wechat_pay" edge to the WeChatPay entity.
func (m *OrderInfoMutation) RemovedWechatPayIDs() (ids []int) {
	for id := range m.removedwechat_pay {
		ids = append(ids, id)
	}
	return
}

// WechatPayIDs returns the "wechat_pay" edge IDs in the mutation.
func (m *OrderInfoMutation) WechatPayIDs() (ids []int) {
	for id := range m.wechat_pay {
		ids = append(ids, id)
	}
	return
}

// ResetWechatPay resets all changes to the "wechat_pay" edge.
func (m *OrderInfoMutation) ResetWechatPay() {
	m.wechat_pay = nil
	m.clearedwechat_pay = false
	m.removedwechat_pay = nil
}

// Op returns the operation name.
func (m *OrderInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderInfo).
func (m *OrderInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderInfoMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, orderinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderinfo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, orderinfo.FieldDeletedAt)
	}
	if m.order_number != nil {
		fields = append(fields, orderinfo.FieldOrderNumber)
	}
	if m.pay_method != nil {
		fields = append(fields, orderinfo.FieldPayMethod)
	}
	if m.pay_money != nil {
		fields = append(fields, orderinfo.FieldPayMoney)
	}
	if m.remark != nil {
		fields = append(fields, orderinfo.FieldRemark)
	}
	if m.status != nil {
		fields = append(fields, orderinfo.FieldStatus)
	}
	if m.delivery_status != nil {
		fields = append(fields, orderinfo.FieldDeliveryStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderinfo.FieldCreatedAt:
		return m.CreatedAt()
	case orderinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderinfo.FieldDeletedAt:
		return m.DeletedAt()
	case orderinfo.FieldOrderNumber:
		return m.OrderNumber()
	case orderinfo.FieldPayMethod:
		return m.PayMethod()
	case orderinfo.FieldPayMoney:
		return m.PayMoney()
	case orderinfo.FieldRemark:
		return m.Remark()
	case orderinfo.FieldStatus:
		return m.Status()
	case orderinfo.FieldDeliveryStatus:
		return m.DeliveryStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderinfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orderinfo.FieldOrderNumber:
		return m.OldOrderNumber(ctx)
	case orderinfo.FieldPayMethod:
		return m.OldPayMethod(ctx)
	case orderinfo.FieldPayMoney:
		return m.OldPayMoney(ctx)
	case orderinfo.FieldRemark:
		return m.OldRemark(ctx)
	case orderinfo.FieldStatus:
		return m.OldStatus(ctx)
	case orderinfo.FieldDeliveryStatus:
		return m.OldDeliveryStatus(ctx)
	}
	return nil, fmt.Errorf("unknown OrderInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderinfo.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orderinfo.FieldOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNumber(v)
		return nil
	case orderinfo.FieldPayMethod:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayMethod(v)
		return nil
	case orderinfo.FieldPayMoney:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayMoney(v)
		return nil
	case orderinfo.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case orderinfo.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case orderinfo.FieldDeliveryStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryStatus(v)
		return nil
	}
	return fmt.Errorf("unknown OrderInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderInfoMutation) AddedFields() []string {
	var fields []string
	if m.addpay_method != nil {
		fields = append(fields, orderinfo.FieldPayMethod)
	}
	if m.addpay_money != nil {
		fields = append(fields, orderinfo.FieldPayMoney)
	}
	if m.addstatus != nil {
		fields = append(fields, orderinfo.FieldStatus)
	}
	if m.adddelivery_status != nil {
		fields = append(fields, orderinfo.FieldDeliveryStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderinfo.FieldPayMethod:
		return m.AddedPayMethod()
	case orderinfo.FieldPayMoney:
		return m.AddedPayMoney()
	case orderinfo.FieldStatus:
		return m.AddedStatus()
	case orderinfo.FieldDeliveryStatus:
		return m.AddedDeliveryStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderinfo.FieldPayMethod:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayMethod(v)
		return nil
	case orderinfo.FieldPayMoney:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayMoney(v)
		return nil
	case orderinfo.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case orderinfo.FieldDeliveryStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeliveryStatus(v)
		return nil
	}
	return fmt.Errorf("unknown OrderInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderinfo.FieldUpdatedAt) {
		fields = append(fields, orderinfo.FieldUpdatedAt)
	}
	if m.FieldCleared(orderinfo.FieldDeletedAt) {
		fields = append(fields, orderinfo.FieldDeletedAt)
	}
	if m.FieldCleared(orderinfo.FieldPayMethod) {
		fields = append(fields, orderinfo.FieldPayMethod)
	}
	if m.FieldCleared(orderinfo.FieldRemark) {
		fields = append(fields, orderinfo.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderInfoMutation) ClearField(name string) error {
	switch name {
	case orderinfo.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orderinfo.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case orderinfo.FieldPayMethod:
		m.ClearPayMethod()
		return nil
	case orderinfo.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown OrderInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderInfoMutation) ResetField(name string) error {
	switch name {
	case orderinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderinfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orderinfo.FieldOrderNumber:
		m.ResetOrderNumber()
		return nil
	case orderinfo.FieldPayMethod:
		m.ResetPayMethod()
		return nil
	case orderinfo.FieldPayMoney:
		m.ResetPayMoney()
		return nil
	case orderinfo.FieldRemark:
		m.ResetRemark()
		return nil
	case orderinfo.FieldStatus:
		m.ResetStatus()
		return nil
	case orderinfo.FieldDeliveryStatus:
		m.ResetDeliveryStatus()
		return nil
	}
	return fmt.Errorf("unknown OrderInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.customer != nil {
		edges = append(edges, orderinfo.EdgeCustomer)
	}
	if m.order_goods_sku != nil {
		edges = append(edges, orderinfo.EdgeOrderGoodsSku)
	}
	if m.order_address != nil {
		edges = append(edges, orderinfo.EdgeOrderAddress)
	}
	if m.wechat_pay != nil {
		edges = append(edges, orderinfo.EdgeWechatPay)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderinfo.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case orderinfo.EdgeOrderGoodsSku:
		ids := make([]ent.Value, 0, len(m.order_goods_sku))
		for id := range m.order_goods_sku {
			ids = append(ids, id)
		}
		return ids
	case orderinfo.EdgeOrderAddress:
		ids := make([]ent.Value, 0, len(m.order_address))
		for id := range m.order_address {
			ids = append(ids, id)
		}
		return ids
	case orderinfo.EdgeWechatPay:
		ids := make([]ent.Value, 0, len(m.wechat_pay))
		for id := range m.wechat_pay {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedorder_goods_sku != nil {
		edges = append(edges, orderinfo.EdgeOrderGoodsSku)
	}
	if m.removedorder_address != nil {
		edges = append(edges, orderinfo.EdgeOrderAddress)
	}
	if m.removedwechat_pay != nil {
		edges = append(edges, orderinfo.EdgeWechatPay)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderinfo.EdgeOrderGoodsSku:
		ids := make([]ent.Value, 0, len(m.removedorder_goods_sku))
		for id := range m.removedorder_goods_sku {
			ids = append(ids, id)
		}
		return ids
	case orderinfo.EdgeOrderAddress:
		ids := make([]ent.Value, 0, len(m.removedorder_address))
		for id := range m.removedorder_address {
			ids = append(ids, id)
		}
		return ids
	case orderinfo.EdgeWechatPay:
		ids := make([]ent.Value, 0, len(m.removedwechat_pay))
		for id := range m.removedwechat_pay {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcustomer {
		edges = append(edges, orderinfo.EdgeCustomer)
	}
	if m.clearedorder_goods_sku {
		edges = append(edges, orderinfo.EdgeOrderGoodsSku)
	}
	if m.clearedorder_address {
		edges = append(edges, orderinfo.EdgeOrderAddress)
	}
	if m.clearedwechat_pay {
		edges = append(edges, orderinfo.EdgeWechatPay)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case orderinfo.EdgeCustomer:
		return m.clearedcustomer
	case orderinfo.EdgeOrderGoodsSku:
		return m.clearedorder_goods_sku
	case orderinfo.EdgeOrderAddress:
		return m.clearedorder_address
	case orderinfo.EdgeWechatPay:
		return m.clearedwechat_pay
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderInfoMutation) ClearEdge(name string) error {
	switch name {
	case orderinfo.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown OrderInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderInfoMutation) ResetEdge(name string) error {
	switch name {
	case orderinfo.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case orderinfo.EdgeOrderGoodsSku:
		m.ResetOrderGoodsSku()
		return nil
	case orderinfo.EdgeOrderAddress:
		m.ResetOrderAddress()
		return nil
	case orderinfo.EdgeWechatPay:
		m.ResetWechatPay()
		return nil
	}
	return fmt.Errorf("unknown OrderInfo edge %s", name)
}

// WeChatPayMutation represents an operation that mutates the WeChatPay nodes in the graph.
type WeChatPayMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	out_trade_no      *string
	transaction_id    *string
	trade_type        *wechatpay.TradeType
	bank_type         *string
	success_time      *time.Time
	payer_currency    *string
	payer_total       *int32
	addpayer_total    *int32
	trade_state       *int8
	addtrade_state    *int8
	clearedFields     map[string]struct{}
	order_info        *int
	clearedorder_info bool
	done              bool
	oldValue          func(context.Context) (*WeChatPay, error)
	predicates        []predicate.WeChatPay
}

var _ ent.Mutation = (*WeChatPayMutation)(nil)

// wechatpayOption allows management of the mutation configuration using functional options.
type wechatpayOption func(*WeChatPayMutation)

// newWeChatPayMutation creates new mutation for the WeChatPay entity.
func newWeChatPayMutation(c config, op Op, opts ...wechatpayOption) *WeChatPayMutation {
	m := &WeChatPayMutation{
		config:        c,
		op:            op,
		typ:           TypeWeChatPay,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWeChatPayID sets the ID field of the mutation.
func withWeChatPayID(id int) wechatpayOption {
	return func(m *WeChatPayMutation) {
		var (
			err   error
			once  sync.Once
			value *WeChatPay
		)
		m.oldValue = func(ctx context.Context) (*WeChatPay, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WeChatPay.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWeChatPay sets the old WeChatPay of the mutation.
func withWeChatPay(node *WeChatPay) wechatpayOption {
	return func(m *WeChatPayMutation) {
		m.oldValue = func(context.Context) (*WeChatPay, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WeChatPayMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WeChatPayMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *WeChatPayMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *WeChatPayMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WeChatPayMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WeChatPay entity.
// If the WeChatPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeChatPayMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WeChatPayMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WeChatPayMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WeChatPayMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WeChatPay entity.
// If the WeChatPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeChatPayMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *WeChatPayMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[wechatpay.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *WeChatPayMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[wechatpay.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WeChatPayMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, wechatpay.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WeChatPayMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WeChatPayMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the WeChatPay entity.
// If the WeChatPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeChatPayMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WeChatPayMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[wechatpay.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WeChatPayMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[wechatpay.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WeChatPayMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, wechatpay.FieldDeletedAt)
}

// SetOutTradeNo sets the "out_trade_no" field.
func (m *WeChatPayMutation) SetOutTradeNo(s string) {
	m.out_trade_no = &s
}

// OutTradeNo returns the value of the "out_trade_no" field in the mutation.
func (m *WeChatPayMutation) OutTradeNo() (r string, exists bool) {
	v := m.out_trade_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOutTradeNo returns the old "out_trade_no" field's value of the WeChatPay entity.
// If the WeChatPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeChatPayMutation) OldOutTradeNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOutTradeNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOutTradeNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutTradeNo: %w", err)
	}
	return oldValue.OutTradeNo, nil
}

// ClearOutTradeNo clears the value of the "out_trade_no" field.
func (m *WeChatPayMutation) ClearOutTradeNo() {
	m.out_trade_no = nil
	m.clearedFields[wechatpay.FieldOutTradeNo] = struct{}{}
}

// OutTradeNoCleared returns if the "out_trade_no" field was cleared in this mutation.
func (m *WeChatPayMutation) OutTradeNoCleared() bool {
	_, ok := m.clearedFields[wechatpay.FieldOutTradeNo]
	return ok
}

// ResetOutTradeNo resets all changes to the "out_trade_no" field.
func (m *WeChatPayMutation) ResetOutTradeNo() {
	m.out_trade_no = nil
	delete(m.clearedFields, wechatpay.FieldOutTradeNo)
}

// SetTransactionID sets the "transaction_id" field.
func (m *WeChatPayMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *WeChatPayMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the WeChatPay entity.
// If the WeChatPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeChatPayMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ClearTransactionID clears the value of the "transaction_id" field.
func (m *WeChatPayMutation) ClearTransactionID() {
	m.transaction_id = nil
	m.clearedFields[wechatpay.FieldTransactionID] = struct{}{}
}

// TransactionIDCleared returns if the "transaction_id" field was cleared in this mutation.
func (m *WeChatPayMutation) TransactionIDCleared() bool {
	_, ok := m.clearedFields[wechatpay.FieldTransactionID]
	return ok
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *WeChatPayMutation) ResetTransactionID() {
	m.transaction_id = nil
	delete(m.clearedFields, wechatpay.FieldTransactionID)
}

// SetTradeType sets the "trade_type" field.
func (m *WeChatPayMutation) SetTradeType(wt wechatpay.TradeType) {
	m.trade_type = &wt
}

// TradeType returns the value of the "trade_type" field in the mutation.
func (m *WeChatPayMutation) TradeType() (r wechatpay.TradeType, exists bool) {
	v := m.trade_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTradeType returns the old "trade_type" field's value of the WeChatPay entity.
// If the WeChatPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeChatPayMutation) OldTradeType(ctx context.Context) (v wechatpay.TradeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTradeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTradeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTradeType: %w", err)
	}
	return oldValue.TradeType, nil
}

// ClearTradeType clears the value of the "trade_type" field.
func (m *WeChatPayMutation) ClearTradeType() {
	m.trade_type = nil
	m.clearedFields[wechatpay.FieldTradeType] = struct{}{}
}

// TradeTypeCleared returns if the "trade_type" field was cleared in this mutation.
func (m *WeChatPayMutation) TradeTypeCleared() bool {
	_, ok := m.clearedFields[wechatpay.FieldTradeType]
	return ok
}

// ResetTradeType resets all changes to the "trade_type" field.
func (m *WeChatPayMutation) ResetTradeType() {
	m.trade_type = nil
	delete(m.clearedFields, wechatpay.FieldTradeType)
}

// SetBankType sets the "bank_type" field.
func (m *WeChatPayMutation) SetBankType(s string) {
	m.bank_type = &s
}

// BankType returns the value of the "bank_type" field in the mutation.
func (m *WeChatPayMutation) BankType() (r string, exists bool) {
	v := m.bank_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBankType returns the old "bank_type" field's value of the WeChatPay entity.
// If the WeChatPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeChatPayMutation) OldBankType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBankType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBankType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankType: %w", err)
	}
	return oldValue.BankType, nil
}

// ClearBankType clears the value of the "bank_type" field.
func (m *WeChatPayMutation) ClearBankType() {
	m.bank_type = nil
	m.clearedFields[wechatpay.FieldBankType] = struct{}{}
}

// BankTypeCleared returns if the "bank_type" field was cleared in this mutation.
func (m *WeChatPayMutation) BankTypeCleared() bool {
	_, ok := m.clearedFields[wechatpay.FieldBankType]
	return ok
}

// ResetBankType resets all changes to the "bank_type" field.
func (m *WeChatPayMutation) ResetBankType() {
	m.bank_type = nil
	delete(m.clearedFields, wechatpay.FieldBankType)
}

// SetSuccessTime sets the "success_time" field.
func (m *WeChatPayMutation) SetSuccessTime(t time.Time) {
	m.success_time = &t
}

// SuccessTime returns the value of the "success_time" field in the mutation.
func (m *WeChatPayMutation) SuccessTime() (r time.Time, exists bool) {
	v := m.success_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessTime returns the old "success_time" field's value of the WeChatPay entity.
// If the WeChatPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeChatPayMutation) OldSuccessTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSuccessTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSuccessTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessTime: %w", err)
	}
	return oldValue.SuccessTime, nil
}

// ClearSuccessTime clears the value of the "success_time" field.
func (m *WeChatPayMutation) ClearSuccessTime() {
	m.success_time = nil
	m.clearedFields[wechatpay.FieldSuccessTime] = struct{}{}
}

// SuccessTimeCleared returns if the "success_time" field was cleared in this mutation.
func (m *WeChatPayMutation) SuccessTimeCleared() bool {
	_, ok := m.clearedFields[wechatpay.FieldSuccessTime]
	return ok
}

// ResetSuccessTime resets all changes to the "success_time" field.
func (m *WeChatPayMutation) ResetSuccessTime() {
	m.success_time = nil
	delete(m.clearedFields, wechatpay.FieldSuccessTime)
}

// SetPayerCurrency sets the "payer_currency" field.
func (m *WeChatPayMutation) SetPayerCurrency(s string) {
	m.payer_currency = &s
}

// PayerCurrency returns the value of the "payer_currency" field in the mutation.
func (m *WeChatPayMutation) PayerCurrency() (r string, exists bool) {
	v := m.payer_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldPayerCurrency returns the old "payer_currency" field's value of the WeChatPay entity.
// If the WeChatPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeChatPayMutation) OldPayerCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayerCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayerCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayerCurrency: %w", err)
	}
	return oldValue.PayerCurrency, nil
}

// ClearPayerCurrency clears the value of the "payer_currency" field.
func (m *WeChatPayMutation) ClearPayerCurrency() {
	m.payer_currency = nil
	m.clearedFields[wechatpay.FieldPayerCurrency] = struct{}{}
}

// PayerCurrencyCleared returns if the "payer_currency" field was cleared in this mutation.
func (m *WeChatPayMutation) PayerCurrencyCleared() bool {
	_, ok := m.clearedFields[wechatpay.FieldPayerCurrency]
	return ok
}

// ResetPayerCurrency resets all changes to the "payer_currency" field.
func (m *WeChatPayMutation) ResetPayerCurrency() {
	m.payer_currency = nil
	delete(m.clearedFields, wechatpay.FieldPayerCurrency)
}

// SetPayerTotal sets the "payer_total" field.
func (m *WeChatPayMutation) SetPayerTotal(i int32) {
	m.payer_total = &i
	m.addpayer_total = nil
}

// PayerTotal returns the value of the "payer_total" field in the mutation.
func (m *WeChatPayMutation) PayerTotal() (r int32, exists bool) {
	v := m.payer_total
	if v == nil {
		return
	}
	return *v, true
}

// OldPayerTotal returns the old "payer_total" field's value of the WeChatPay entity.
// If the WeChatPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeChatPayMutation) OldPayerTotal(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayerTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayerTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayerTotal: %w", err)
	}
	return oldValue.PayerTotal, nil
}

// AddPayerTotal adds i to the "payer_total" field.
func (m *WeChatPayMutation) AddPayerTotal(i int32) {
	if m.addpayer_total != nil {
		*m.addpayer_total += i
	} else {
		m.addpayer_total = &i
	}
}

// AddedPayerTotal returns the value that was added to the "payer_total" field in this mutation.
func (m *WeChatPayMutation) AddedPayerTotal() (r int32, exists bool) {
	v := m.addpayer_total
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayerTotal clears the value of the "payer_total" field.
func (m *WeChatPayMutation) ClearPayerTotal() {
	m.payer_total = nil
	m.addpayer_total = nil
	m.clearedFields[wechatpay.FieldPayerTotal] = struct{}{}
}

// PayerTotalCleared returns if the "payer_total" field was cleared in this mutation.
func (m *WeChatPayMutation) PayerTotalCleared() bool {
	_, ok := m.clearedFields[wechatpay.FieldPayerTotal]
	return ok
}

// ResetPayerTotal resets all changes to the "payer_total" field.
func (m *WeChatPayMutation) ResetPayerTotal() {
	m.payer_total = nil
	m.addpayer_total = nil
	delete(m.clearedFields, wechatpay.FieldPayerTotal)
}

// SetTradeState sets the "trade_state" field.
func (m *WeChatPayMutation) SetTradeState(i int8) {
	m.trade_state = &i
	m.addtrade_state = nil
}

// TradeState returns the value of the "trade_state" field in the mutation.
func (m *WeChatPayMutation) TradeState() (r int8, exists bool) {
	v := m.trade_state
	if v == nil {
		return
	}
	return *v, true
}

// OldTradeState returns the old "trade_state" field's value of the WeChatPay entity.
// If the WeChatPay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeChatPayMutation) OldTradeState(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTradeState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTradeState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTradeState: %w", err)
	}
	return oldValue.TradeState, nil
}

// AddTradeState adds i to the "trade_state" field.
func (m *WeChatPayMutation) AddTradeState(i int8) {
	if m.addtrade_state != nil {
		*m.addtrade_state += i
	} else {
		m.addtrade_state = &i
	}
}

// AddedTradeState returns the value that was added to the "trade_state" field in this mutation.
func (m *WeChatPayMutation) AddedTradeState() (r int8, exists bool) {
	v := m.addtrade_state
	if v == nil {
		return
	}
	return *v, true
}

// ClearTradeState clears the value of the "trade_state" field.
func (m *WeChatPayMutation) ClearTradeState() {
	m.trade_state = nil
	m.addtrade_state = nil
	m.clearedFields[wechatpay.FieldTradeState] = struct{}{}
}

// TradeStateCleared returns if the "trade_state" field was cleared in this mutation.
func (m *WeChatPayMutation) TradeStateCleared() bool {
	_, ok := m.clearedFields[wechatpay.FieldTradeState]
	return ok
}

// ResetTradeState resets all changes to the "trade_state" field.
func (m *WeChatPayMutation) ResetTradeState() {
	m.trade_state = nil
	m.addtrade_state = nil
	delete(m.clearedFields, wechatpay.FieldTradeState)
}

// SetOrderInfoID sets the "order_info" edge to the OrderInfo entity by id.
func (m *WeChatPayMutation) SetOrderInfoID(id int) {
	m.order_info = &id
}

// ClearOrderInfo clears the "order_info" edge to the OrderInfo entity.
func (m *WeChatPayMutation) ClearOrderInfo() {
	m.clearedorder_info = true
}

// OrderInfoCleared reports if the "order_info" edge to the OrderInfo entity was cleared.
func (m *WeChatPayMutation) OrderInfoCleared() bool {
	return m.clearedorder_info
}

// OrderInfoID returns the "order_info" edge ID in the mutation.
func (m *WeChatPayMutation) OrderInfoID() (id int, exists bool) {
	if m.order_info != nil {
		return *m.order_info, true
	}
	return
}

// OrderInfoIDs returns the "order_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderInfoID instead. It exists only for internal usage by the builders.
func (m *WeChatPayMutation) OrderInfoIDs() (ids []int) {
	if id := m.order_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderInfo resets all changes to the "order_info" edge.
func (m *WeChatPayMutation) ResetOrderInfo() {
	m.order_info = nil
	m.clearedorder_info = false
}

// Op returns the operation name.
func (m *WeChatPayMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WeChatPay).
func (m *WeChatPayMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WeChatPayMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, wechatpay.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, wechatpay.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, wechatpay.FieldDeletedAt)
	}
	if m.out_trade_no != nil {
		fields = append(fields, wechatpay.FieldOutTradeNo)
	}
	if m.transaction_id != nil {
		fields = append(fields, wechatpay.FieldTransactionID)
	}
	if m.trade_type != nil {
		fields = append(fields, wechatpay.FieldTradeType)
	}
	if m.bank_type != nil {
		fields = append(fields, wechatpay.FieldBankType)
	}
	if m.success_time != nil {
		fields = append(fields, wechatpay.FieldSuccessTime)
	}
	if m.payer_currency != nil {
		fields = append(fields, wechatpay.FieldPayerCurrency)
	}
	if m.payer_total != nil {
		fields = append(fields, wechatpay.FieldPayerTotal)
	}
	if m.trade_state != nil {
		fields = append(fields, wechatpay.FieldTradeState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WeChatPayMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wechatpay.FieldCreatedAt:
		return m.CreatedAt()
	case wechatpay.FieldUpdatedAt:
		return m.UpdatedAt()
	case wechatpay.FieldDeletedAt:
		return m.DeletedAt()
	case wechatpay.FieldOutTradeNo:
		return m.OutTradeNo()
	case wechatpay.FieldTransactionID:
		return m.TransactionID()
	case wechatpay.FieldTradeType:
		return m.TradeType()
	case wechatpay.FieldBankType:
		return m.BankType()
	case wechatpay.FieldSuccessTime:
		return m.SuccessTime()
	case wechatpay.FieldPayerCurrency:
		return m.PayerCurrency()
	case wechatpay.FieldPayerTotal:
		return m.PayerTotal()
	case wechatpay.FieldTradeState:
		return m.TradeState()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WeChatPayMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wechatpay.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case wechatpay.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case wechatpay.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case wechatpay.FieldOutTradeNo:
		return m.OldOutTradeNo(ctx)
	case wechatpay.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case wechatpay.FieldTradeType:
		return m.OldTradeType(ctx)
	case wechatpay.FieldBankType:
		return m.OldBankType(ctx)
	case wechatpay.FieldSuccessTime:
		return m.OldSuccessTime(ctx)
	case wechatpay.FieldPayerCurrency:
		return m.OldPayerCurrency(ctx)
	case wechatpay.FieldPayerTotal:
		return m.OldPayerTotal(ctx)
	case wechatpay.FieldTradeState:
		return m.OldTradeState(ctx)
	}
	return nil, fmt.Errorf("unknown WeChatPay field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WeChatPayMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wechatpay.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case wechatpay.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case wechatpay.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case wechatpay.FieldOutTradeNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutTradeNo(v)
		return nil
	case wechatpay.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case wechatpay.FieldTradeType:
		v, ok := value.(wechatpay.TradeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTradeType(v)
		return nil
	case wechatpay.FieldBankType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankType(v)
		return nil
	case wechatpay.FieldSuccessTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessTime(v)
		return nil
	case wechatpay.FieldPayerCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayerCurrency(v)
		return nil
	case wechatpay.FieldPayerTotal:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayerTotal(v)
		return nil
	case wechatpay.FieldTradeState:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTradeState(v)
		return nil
	}
	return fmt.Errorf("unknown WeChatPay field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WeChatPayMutation) AddedFields() []string {
	var fields []string
	if m.addpayer_total != nil {
		fields = append(fields, wechatpay.FieldPayerTotal)
	}
	if m.addtrade_state != nil {
		fields = append(fields, wechatpay.FieldTradeState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WeChatPayMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wechatpay.FieldPayerTotal:
		return m.AddedPayerTotal()
	case wechatpay.FieldTradeState:
		return m.AddedTradeState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WeChatPayMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wechatpay.FieldPayerTotal:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayerTotal(v)
		return nil
	case wechatpay.FieldTradeState:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTradeState(v)
		return nil
	}
	return fmt.Errorf("unknown WeChatPay numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WeChatPayMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(wechatpay.FieldUpdatedAt) {
		fields = append(fields, wechatpay.FieldUpdatedAt)
	}
	if m.FieldCleared(wechatpay.FieldDeletedAt) {
		fields = append(fields, wechatpay.FieldDeletedAt)
	}
	if m.FieldCleared(wechatpay.FieldOutTradeNo) {
		fields = append(fields, wechatpay.FieldOutTradeNo)
	}
	if m.FieldCleared(wechatpay.FieldTransactionID) {
		fields = append(fields, wechatpay.FieldTransactionID)
	}
	if m.FieldCleared(wechatpay.FieldTradeType) {
		fields = append(fields, wechatpay.FieldTradeType)
	}
	if m.FieldCleared(wechatpay.FieldBankType) {
		fields = append(fields, wechatpay.FieldBankType)
	}
	if m.FieldCleared(wechatpay.FieldSuccessTime) {
		fields = append(fields, wechatpay.FieldSuccessTime)
	}
	if m.FieldCleared(wechatpay.FieldPayerCurrency) {
		fields = append(fields, wechatpay.FieldPayerCurrency)
	}
	if m.FieldCleared(wechatpay.FieldPayerTotal) {
		fields = append(fields, wechatpay.FieldPayerTotal)
	}
	if m.FieldCleared(wechatpay.FieldTradeState) {
		fields = append(fields, wechatpay.FieldTradeState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WeChatPayMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WeChatPayMutation) ClearField(name string) error {
	switch name {
	case wechatpay.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case wechatpay.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case wechatpay.FieldOutTradeNo:
		m.ClearOutTradeNo()
		return nil
	case wechatpay.FieldTransactionID:
		m.ClearTransactionID()
		return nil
	case wechatpay.FieldTradeType:
		m.ClearTradeType()
		return nil
	case wechatpay.FieldBankType:
		m.ClearBankType()
		return nil
	case wechatpay.FieldSuccessTime:
		m.ClearSuccessTime()
		return nil
	case wechatpay.FieldPayerCurrency:
		m.ClearPayerCurrency()
		return nil
	case wechatpay.FieldPayerTotal:
		m.ClearPayerTotal()
		return nil
	case wechatpay.FieldTradeState:
		m.ClearTradeState()
		return nil
	}
	return fmt.Errorf("unknown WeChatPay nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WeChatPayMutation) ResetField(name string) error {
	switch name {
	case wechatpay.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case wechatpay.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case wechatpay.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case wechatpay.FieldOutTradeNo:
		m.ResetOutTradeNo()
		return nil
	case wechatpay.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case wechatpay.FieldTradeType:
		m.ResetTradeType()
		return nil
	case wechatpay.FieldBankType:
		m.ResetBankType()
		return nil
	case wechatpay.FieldSuccessTime:
		m.ResetSuccessTime()
		return nil
	case wechatpay.FieldPayerCurrency:
		m.ResetPayerCurrency()
		return nil
	case wechatpay.FieldPayerTotal:
		m.ResetPayerTotal()
		return nil
	case wechatpay.FieldTradeState:
		m.ResetTradeState()
		return nil
	}
	return fmt.Errorf("unknown WeChatPay field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WeChatPayMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.order_info != nil {
		edges = append(edges, wechatpay.EdgeOrderInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WeChatPayMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wechatpay.EdgeOrderInfo:
		if id := m.order_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WeChatPayMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WeChatPayMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WeChatPayMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorder_info {
		edges = append(edges, wechatpay.EdgeOrderInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WeChatPayMutation) EdgeCleared(name string) bool {
	switch name {
	case wechatpay.EdgeOrderInfo:
		return m.clearedorder_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WeChatPayMutation) ClearEdge(name string) error {
	switch name {
	case wechatpay.EdgeOrderInfo:
		m.ClearOrderInfo()
		return nil
	}
	return fmt.Errorf("unknown WeChatPay unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WeChatPayMutation) ResetEdge(name string) error {
	switch name {
	case wechatpay.EdgeOrderInfo:
		m.ResetOrderInfo()
		return nil
	}
	return fmt.Errorf("unknown WeChatPay edge %s", name)
}
